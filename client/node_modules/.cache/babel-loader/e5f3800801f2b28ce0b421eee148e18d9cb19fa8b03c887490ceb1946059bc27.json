{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute, Matrix4 } from \"three\";\nconst ID_ATTR_NAME = \"_batch_id_\";\nconst _identityMatrix = /* @__PURE__ */new Matrix4();\nconst _zeroScaleMatrix = /* @__PURE__ */(() => new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1))();\nconst batchingParsVertex = /* glsl */\n`\n#ifdef BATCHING\n\tattribute float ${ID_ATTR_NAME};\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\n\t}\n#endif\n`;\nconst batchingbaseVertex = /* glsl */\n`\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( ${ID_ATTR_NAME} );\n#endif\n`;\nconst batchingnormalVertex = /* glsl */\n`\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`;\nconst batchingVertex = /* glsl */\n`\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`;\nfunction copyAttributeData(src, target, targetOffset = 0) {\n  const itemSize = target.itemSize;\n  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {\n    const vertexCount = src.count;\n    for (let i = 0; i < vertexCount; i++) {\n      for (let c = 0; c < itemSize; c++) {\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c));\n      }\n    }\n  } else {\n    target.array.set(src.array, targetOffset * itemSize);\n  }\n  target.needsUpdate = true;\n}\nclass BatchedMesh extends Mesh {\n  constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {\n    super(new BufferGeometry(), material);\n    __publicField(this, \"_vertexStarts\");\n    __publicField(this, \"_vertexCounts\");\n    __publicField(this, \"_indexStarts\");\n    __publicField(this, \"_indexCounts\");\n    __publicField(this, \"_reservedRanges\");\n    __publicField(this, \"_visible\");\n    __publicField(this, \"_active\");\n    __publicField(this, \"_maxGeometryCount\");\n    __publicField(this, \"_maxVertexCount\");\n    __publicField(this, \"_maxIndexCount\");\n    __publicField(this, \"_geometryInitialized\");\n    __publicField(this, \"_geometryCount\");\n    __publicField(this, \"_matrices\");\n    __publicField(this, \"_matricesTexture\");\n    __publicField(this, \"_customUniforms\");\n    this._vertexStarts = [];\n    this._vertexCounts = [];\n    this._indexStarts = [];\n    this._indexCounts = [];\n    this._reservedRanges = [];\n    this._visible = [];\n    this._active = [];\n    this._maxGeometryCount = maxGeometryCount;\n    this._maxVertexCount = maxVertexCount;\n    this._maxIndexCount = maxIndexCount;\n    this._geometryInitialized = false;\n    this._geometryCount = 0;\n    this._matrices = [];\n    this._matricesTexture = null;\n    this.frustumCulled = false;\n    this._customUniforms = {\n      batchingTexture: {\n        value: null\n      }\n    };\n    this._initMatricesTexture();\n    this._initShader();\n    this.onBeforeRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true;\n      }\n    };\n    this.onAfterRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false;\n      }\n    };\n  }\n  _initMatricesTexture() {\n    let size = Math.sqrt(this._maxGeometryCount * 4);\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const matricesArray = new Float32Array(size * size * 4);\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n    this._matricesTexture = matricesTexture;\n    this._customUniforms.batchingTexture.value = this._matricesTexture;\n  }\n  _initShader() {\n    const material = this.material;\n    const currentOnBeforeCompile = material.onBeforeCompile;\n    const customUniforms = this._customUniforms;\n    material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      parameters.vertexShader = parameters.vertexShader.replace(\"#include <skinning_pars_vertex>\", \"#include <skinning_pars_vertex>\\n\" + batchingParsVertex).replace(\"#include <uv_vertex>\", \"#include <uv_vertex>\\n\" + batchingbaseVertex).replace(\"#include <skinnormal_vertex>\", \"#include <skinnormal_vertex>\\n\" + batchingnormalVertex).replace(\"#include <skinning_vertex>\", \"#include <skinning_vertex>\\n\" + batchingVertex);\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName];\n      }\n      currentOnBeforeCompile.call(this, parameters, renderer);\n    };\n    material.defines = material.defines || {};\n    material.defines.BATCHING = false;\n  }\n  _initializeGeometry(reference) {\n    const geometry = this.geometry;\n    const maxVertexCount = this._maxVertexCount;\n    const maxGeometryCount = this._maxGeometryCount;\n    const maxIndexCount = this._maxIndexCount;\n    if (this._geometryInitialized === false) {\n      for (const attributeName in reference.attributes) {\n        const srcAttribute = reference.getAttribute(attributeName);\n        const {\n          array,\n          itemSize,\n          normalized\n        } = srcAttribute;\n        const dstArray = new array.constructor(maxVertexCount * itemSize);\n        const dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);\n        dstAttribute.setUsage(srcAttribute.usage);\n        geometry.setAttribute(attributeName, dstAttribute);\n      }\n      if (reference.getIndex() !== null) {\n        const indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);\n        geometry.setIndex(new BufferAttribute(indexArray, 1));\n      }\n      const idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount);\n      geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1));\n      this._geometryInitialized = true;\n    }\n  }\n  // Make sure the geometry is compatible with the existing combined geometry atributes\n  _validateGeometry(geometry) {\n    if (geometry.getAttribute(ID_ATTR_NAME)) {\n      throw new Error(`BatchedMesh: Geometry cannot use attribute \"${ID_ATTR_NAME}\"`);\n    }\n    const batchGeometry = this.geometry;\n    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n      throw new Error('BatchedMesh: All geometries must consistently have \"index\".');\n    }\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue;\n      }\n      if (!geometry.hasAttribute(attributeName)) {\n        throw new Error(`BatchedMesh: Added geometry missing \"${attributeName}\". All geometries must have consistent attributes.`);\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n        throw new Error(\"BatchedMesh: All attributes must have a consistent itemSize and normalized value.\");\n      }\n    }\n  }\n  getGeometryCount() {\n    return this._geometryCount;\n  }\n  getVertexCount() {\n    const reservedRanges = this._reservedRanges;\n    if (reservedRanges.length === 0) {\n      return 0;\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1];\n      return finalRange.vertexStart + finalRange.vertexCount;\n    }\n  }\n  getIndexCount() {\n    const reservedRanges = this._reservedRanges;\n    const geometry = this.geometry;\n    if (geometry.getIndex() === null || reservedRanges.length === 0) {\n      return 0;\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1];\n      return finalRange.indexStart + finalRange.indexCount;\n    }\n  }\n  addGeometry(geometry, vertexCount = -1, indexCount = -1) {\n    this._initializeGeometry(geometry);\n    this._validateGeometry(geometry);\n    if (this._geometryCount >= this._maxGeometryCount) {\n      throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n    }\n    const range = {\n      vertexStart: -1,\n      vertexCount: -1,\n      indexStart: -1,\n      indexCount: -1\n    };\n    let lastRange = null;\n    const reservedRanges = this._reservedRanges;\n    if (this._geometryCount !== 0) {\n      lastRange = reservedRanges[reservedRanges.length - 1];\n    }\n    if (vertexCount === -1) {\n      range.vertexCount = geometry.getAttribute(\"position\").count;\n    } else {\n      range.vertexCount = vertexCount;\n    }\n    if (lastRange === null) {\n      range.vertexStart = 0;\n    } else {\n      range.vertexStart = lastRange.vertexStart + lastRange.vertexCount;\n    }\n    if (geometry.getIndex() !== null) {\n      if (indexCount === -1) {\n        range.indexCount = geometry.getIndex().count;\n      } else {\n        range.indexCount = indexCount;\n      }\n      if (lastRange === null) {\n        range.indexStart = 0;\n      } else {\n        range.indexStart = lastRange.indexStart + lastRange.indexCount;\n      }\n    }\n    if (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount || range.vertexStart + range.vertexCount > this._maxVertexCount) {\n      throw new Error(\"BatchedMesh: Reserved space request exceeds the maximum buffer size.\");\n    }\n    const indexCounts = this._indexCounts;\n    const indexStarts = this._indexStarts;\n    const vertexCounts = this._vertexCounts;\n    const vertexStarts = this._vertexStarts;\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = this._matricesTexture.image.data;\n    visible.push(true);\n    active.push(true);\n    const geometryId = this._geometryCount;\n    this._geometryCount++;\n    matrices.push(new Matrix4());\n    _identityMatrix.toArray(matricesArray, geometryId * 16);\n    matricesTexture.needsUpdate = true;\n    reservedRanges.push(range);\n    vertexStarts.push(range.vertexStart);\n    vertexCounts.push(range.vertexCount);\n    if (geometry.getIndex() !== null) {\n      indexStarts.push(range.indexCount);\n      indexCounts.push(range.indexCount);\n    }\n    const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME);\n    for (let i = 0; i < range.vertexCount; i++) {\n      idAttribute.setX(range.vertexStart + i, geometryId);\n    }\n    idAttribute.needsUpdate = true;\n    this.setGeometryAt(geometryId, geometry);\n    return geometryId;\n  }\n  /**\n   * @deprecated use `addGeometry` instead.\n   */\n  applyGeometry(geometry) {\n    return this.addGeometry(geometry);\n  }\n  setGeometryAt(id, geometry) {\n    if (id >= this._geometryCount) {\n      throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n    }\n    this._validateGeometry(geometry);\n    const range = this._reservedRanges[id];\n    if (geometry.getIndex() !== null && geometry.getIndex().count > range.indexCount || geometry.attributes.position.count > range.vertexCount) {\n      throw new Error(\"BatchedMesh: Reserved space not large enough for provided geometry.\");\n    }\n    const batchGeometry = this.geometry;\n    const srcPositionAttribute = geometry.getAttribute(\"position\");\n    const hasIndex = batchGeometry.getIndex() !== null;\n    const dstIndex = batchGeometry.getIndex();\n    const srcIndex = geometry.getIndex();\n    const vertexStart = range.vertexStart;\n    const vertexCount = range.vertexCount;\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue;\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      copyAttributeData(srcAttribute, dstAttribute, vertexStart);\n      const itemSize = srcAttribute.itemSize;\n      for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {\n        const index = vertexStart + i;\n        for (let c = 0; c < itemSize; c++) {\n          dstAttribute.setComponent(index, c, 0);\n        }\n      }\n      dstAttribute.needsUpdate = true;\n    }\n    this._vertexCounts[id] = srcPositionAttribute.count;\n    if (hasIndex) {\n      const indexStart = range.indexStart;\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));\n      }\n      for (let i = srcIndex.count, l = range.indexCount; i < l; i++) {\n        dstIndex.setX(indexStart + i, vertexStart);\n      }\n      dstIndex.needsUpdate = true;\n      this._indexCounts[id] = srcIndex.count;\n    }\n    return id;\n  }\n  deleteGeometry(geometryId) {\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= active.length || active[geometryId] === false) {\n      return this;\n    }\n    active[geometryId] = false;\n    _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n    matricesTexture.needsUpdate = true;\n    return this;\n  }\n  optimize() {\n    throw new Error(\"BatchedMesh: Optimize function not implemented.\");\n  }\n  setMatrixAt(geometryId, matrix) {\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return this;\n    }\n    if (visible[geometryId] === true) {\n      matrix.toArray(matricesArray, geometryId * 16);\n      matricesTexture.needsUpdate = true;\n    }\n    matrices[geometryId].copy(matrix);\n    return this;\n  }\n  getMatrixAt(geometryId, matrix) {\n    const matrices = this._matrices;\n    const active = this._active;\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return matrix;\n    }\n    return matrix.copy(matrices[geometryId]);\n  }\n  setVisibleAt(geometryId, value) {\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {\n      return this;\n    }\n    if (value === true) {\n      matrices[geometryId].toArray(matricesArray, geometryId * 16);\n    } else {\n      _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n    }\n    matricesTexture.needsUpdate = true;\n    visible[geometryId] = value;\n    return this;\n  }\n  getVisibleAt(geometryId) {\n    const visible = this._visible;\n    const active = this._active;\n    if (geometryId >= visible.length || active[geometryId] === false) {\n      return false;\n    }\n    return visible[geometryId];\n  }\n  raycast() {\n    console.warn(\"BatchedMesh: Raycast function not implemented.\");\n  }\n  copy() {\n    throw new Error(\"BatchedMesh: Copy function not implemented.\");\n  }\n  toJSON() {\n    throw new Error(\"BatchedMesh: toJSON function not implemented.\");\n  }\n  dispose() {\n    this.geometry.dispose();\n    this._matricesTexture.dispose();\n    this._matricesTexture = null;\n    return this;\n  }\n}\nexport { BatchedMesh };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","Mesh","BufferGeometry","MathUtils","DataTexture","RGBAFormat","FloatType","BufferAttribute","Matrix4","ID_ATTR_NAME","_identityMatrix","_zeroScaleMatrix","set","batchingParsVertex","batchingbaseVertex","batchingnormalVertex","batchingVertex","copyAttributeData","src","target","targetOffset","itemSize","isInterleavedBufferAttribute","array","constructor","vertexCount","count","i","c","setComponent","getComponent","needsUpdate","BatchedMesh","maxGeometryCount","maxVertexCount","maxIndexCount","material","_vertexStarts","_vertexCounts","_indexStarts","_indexCounts","_reservedRanges","_visible","_active","_maxGeometryCount","_maxVertexCount","_maxIndexCount","_geometryInitialized","_geometryCount","_matrices","_matricesTexture","frustumCulled","_customUniforms","batchingTexture","_initMatricesTexture","_initShader","onBeforeRender","defines","BATCHING","onAfterRender","size","Math","sqrt","ceilPowerOfTwo","max","matricesArray","Float32Array","matricesTexture","currentOnBeforeCompile","onBeforeCompile","customUniforms","parameters","renderer","vertexShader","replace","uniformName","uniforms","call","_initializeGeometry","reference","geometry","attributeName","attributes","srcAttribute","getAttribute","normalized","dstArray","dstAttribute","setUsage","usage","setAttribute","getIndex","indexArray","Uint32Array","Uint16Array","setIndex","idArray","_validateGeometry","Error","batchGeometry","Boolean","hasAttribute","getGeometryCount","getVertexCount","reservedRanges","length","finalRange","vertexStart","getIndexCount","indexStart","indexCount","addGeometry","range","lastRange","indexCounts","indexStarts","vertexCounts","vertexStarts","visible","active","matrices","image","data","push","geometryId","toArray","idAttribute","setX","setGeometryAt","applyGeometry","id","position","srcPositionAttribute","hasIndex","dstIndex","srcIndex","l","index","getX","deleteGeometry","optimize","setMatrixAt","matrix","copy","getMatrixAt","setVisibleAt","getVisibleAt","raycast","console","warn","toJSON","dispose"],"sources":["C:/Users/Marcelo/OneDrive/Documents/Desktop/e-traffic system/client/node_modules/three-stdlib/objects/BatchedMesh.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute, Matrix4 } from \"three\";\nconst ID_ATTR_NAME = \"_batch_id_\";\nconst _identityMatrix = /* @__PURE__ */ new Matrix4();\nconst _zeroScaleMatrix = /* @__PURE__ */ (() => new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1))();\nconst batchingParsVertex = (\n  /* glsl */\n  `\n#ifdef BATCHING\n\tattribute float ${ID_ATTR_NAME};\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\n\t}\n#endif\n`\n);\nconst batchingbaseVertex = (\n  /* glsl */\n  `\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( ${ID_ATTR_NAME} );\n#endif\n`\n);\nconst batchingnormalVertex = (\n  /* glsl */\n  `\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`\n);\nconst batchingVertex = (\n  /* glsl */\n  `\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`\n);\nfunction copyAttributeData(src, target, targetOffset = 0) {\n  const itemSize = target.itemSize;\n  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {\n    const vertexCount = src.count;\n    for (let i = 0; i < vertexCount; i++) {\n      for (let c = 0; c < itemSize; c++) {\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c));\n      }\n    }\n  } else {\n    target.array.set(src.array, targetOffset * itemSize);\n  }\n  target.needsUpdate = true;\n}\nclass BatchedMesh extends Mesh {\n  constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {\n    super(new BufferGeometry(), material);\n    __publicField(this, \"_vertexStarts\");\n    __publicField(this, \"_vertexCounts\");\n    __publicField(this, \"_indexStarts\");\n    __publicField(this, \"_indexCounts\");\n    __publicField(this, \"_reservedRanges\");\n    __publicField(this, \"_visible\");\n    __publicField(this, \"_active\");\n    __publicField(this, \"_maxGeometryCount\");\n    __publicField(this, \"_maxVertexCount\");\n    __publicField(this, \"_maxIndexCount\");\n    __publicField(this, \"_geometryInitialized\");\n    __publicField(this, \"_geometryCount\");\n    __publicField(this, \"_matrices\");\n    __publicField(this, \"_matricesTexture\");\n    __publicField(this, \"_customUniforms\");\n    this._vertexStarts = [];\n    this._vertexCounts = [];\n    this._indexStarts = [];\n    this._indexCounts = [];\n    this._reservedRanges = [];\n    this._visible = [];\n    this._active = [];\n    this._maxGeometryCount = maxGeometryCount;\n    this._maxVertexCount = maxVertexCount;\n    this._maxIndexCount = maxIndexCount;\n    this._geometryInitialized = false;\n    this._geometryCount = 0;\n    this._matrices = [];\n    this._matricesTexture = null;\n    this.frustumCulled = false;\n    this._customUniforms = {\n      batchingTexture: { value: null }\n    };\n    this._initMatricesTexture();\n    this._initShader();\n    this.onBeforeRender = function() {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true;\n      }\n    };\n    this.onAfterRender = function() {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false;\n      }\n    };\n  }\n  _initMatricesTexture() {\n    let size = Math.sqrt(this._maxGeometryCount * 4);\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const matricesArray = new Float32Array(size * size * 4);\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n    this._matricesTexture = matricesTexture;\n    this._customUniforms.batchingTexture.value = this._matricesTexture;\n  }\n  _initShader() {\n    const material = this.material;\n    const currentOnBeforeCompile = material.onBeforeCompile;\n    const customUniforms = this._customUniforms;\n    material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      parameters.vertexShader = parameters.vertexShader.replace(\"#include <skinning_pars_vertex>\", \"#include <skinning_pars_vertex>\\n\" + batchingParsVertex).replace(\"#include <uv_vertex>\", \"#include <uv_vertex>\\n\" + batchingbaseVertex).replace(\"#include <skinnormal_vertex>\", \"#include <skinnormal_vertex>\\n\" + batchingnormalVertex).replace(\"#include <skinning_vertex>\", \"#include <skinning_vertex>\\n\" + batchingVertex);\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName];\n      }\n      currentOnBeforeCompile.call(this, parameters, renderer);\n    };\n    material.defines = material.defines || {};\n    material.defines.BATCHING = false;\n  }\n  _initializeGeometry(reference) {\n    const geometry = this.geometry;\n    const maxVertexCount = this._maxVertexCount;\n    const maxGeometryCount = this._maxGeometryCount;\n    const maxIndexCount = this._maxIndexCount;\n    if (this._geometryInitialized === false) {\n      for (const attributeName in reference.attributes) {\n        const srcAttribute = reference.getAttribute(attributeName);\n        const { array, itemSize, normalized } = srcAttribute;\n        const dstArray = new array.constructor(maxVertexCount * itemSize);\n        const dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);\n        dstAttribute.setUsage(srcAttribute.usage);\n        geometry.setAttribute(attributeName, dstAttribute);\n      }\n      if (reference.getIndex() !== null) {\n        const indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);\n        geometry.setIndex(new BufferAttribute(indexArray, 1));\n      }\n      const idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount);\n      geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1));\n      this._geometryInitialized = true;\n    }\n  }\n  // Make sure the geometry is compatible with the existing combined geometry atributes\n  _validateGeometry(geometry) {\n    if (geometry.getAttribute(ID_ATTR_NAME)) {\n      throw new Error(`BatchedMesh: Geometry cannot use attribute \"${ID_ATTR_NAME}\"`);\n    }\n    const batchGeometry = this.geometry;\n    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n      throw new Error('BatchedMesh: All geometries must consistently have \"index\".');\n    }\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue;\n      }\n      if (!geometry.hasAttribute(attributeName)) {\n        throw new Error(\n          `BatchedMesh: Added geometry missing \"${attributeName}\". All geometries must have consistent attributes.`\n        );\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n        throw new Error(\"BatchedMesh: All attributes must have a consistent itemSize and normalized value.\");\n      }\n    }\n  }\n  getGeometryCount() {\n    return this._geometryCount;\n  }\n  getVertexCount() {\n    const reservedRanges = this._reservedRanges;\n    if (reservedRanges.length === 0) {\n      return 0;\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1];\n      return finalRange.vertexStart + finalRange.vertexCount;\n    }\n  }\n  getIndexCount() {\n    const reservedRanges = this._reservedRanges;\n    const geometry = this.geometry;\n    if (geometry.getIndex() === null || reservedRanges.length === 0) {\n      return 0;\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1];\n      return finalRange.indexStart + finalRange.indexCount;\n    }\n  }\n  addGeometry(geometry, vertexCount = -1, indexCount = -1) {\n    this._initializeGeometry(geometry);\n    this._validateGeometry(geometry);\n    if (this._geometryCount >= this._maxGeometryCount) {\n      throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n    }\n    const range = {\n      vertexStart: -1,\n      vertexCount: -1,\n      indexStart: -1,\n      indexCount: -1\n    };\n    let lastRange = null;\n    const reservedRanges = this._reservedRanges;\n    if (this._geometryCount !== 0) {\n      lastRange = reservedRanges[reservedRanges.length - 1];\n    }\n    if (vertexCount === -1) {\n      range.vertexCount = geometry.getAttribute(\"position\").count;\n    } else {\n      range.vertexCount = vertexCount;\n    }\n    if (lastRange === null) {\n      range.vertexStart = 0;\n    } else {\n      range.vertexStart = lastRange.vertexStart + lastRange.vertexCount;\n    }\n    if (geometry.getIndex() !== null) {\n      if (indexCount === -1) {\n        range.indexCount = geometry.getIndex().count;\n      } else {\n        range.indexCount = indexCount;\n      }\n      if (lastRange === null) {\n        range.indexStart = 0;\n      } else {\n        range.indexStart = lastRange.indexStart + lastRange.indexCount;\n      }\n    }\n    if (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount || range.vertexStart + range.vertexCount > this._maxVertexCount) {\n      throw new Error(\"BatchedMesh: Reserved space request exceeds the maximum buffer size.\");\n    }\n    const indexCounts = this._indexCounts;\n    const indexStarts = this._indexStarts;\n    const vertexCounts = this._vertexCounts;\n    const vertexStarts = this._vertexStarts;\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = this._matricesTexture.image.data;\n    visible.push(true);\n    active.push(true);\n    const geometryId = this._geometryCount;\n    this._geometryCount++;\n    matrices.push(new Matrix4());\n    _identityMatrix.toArray(matricesArray, geometryId * 16);\n    matricesTexture.needsUpdate = true;\n    reservedRanges.push(range);\n    vertexStarts.push(range.vertexStart);\n    vertexCounts.push(range.vertexCount);\n    if (geometry.getIndex() !== null) {\n      indexStarts.push(range.indexCount);\n      indexCounts.push(range.indexCount);\n    }\n    const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME);\n    for (let i = 0; i < range.vertexCount; i++) {\n      idAttribute.setX(range.vertexStart + i, geometryId);\n    }\n    idAttribute.needsUpdate = true;\n    this.setGeometryAt(geometryId, geometry);\n    return geometryId;\n  }\n  /**\n   * @deprecated use `addGeometry` instead.\n   */\n  applyGeometry(geometry) {\n    return this.addGeometry(geometry);\n  }\n  setGeometryAt(id, geometry) {\n    if (id >= this._geometryCount) {\n      throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n    }\n    this._validateGeometry(geometry);\n    const range = this._reservedRanges[id];\n    if (geometry.getIndex() !== null && geometry.getIndex().count > range.indexCount || geometry.attributes.position.count > range.vertexCount) {\n      throw new Error(\"BatchedMesh: Reserved space not large enough for provided geometry.\");\n    }\n    const batchGeometry = this.geometry;\n    const srcPositionAttribute = geometry.getAttribute(\"position\");\n    const hasIndex = batchGeometry.getIndex() !== null;\n    const dstIndex = batchGeometry.getIndex();\n    const srcIndex = geometry.getIndex();\n    const vertexStart = range.vertexStart;\n    const vertexCount = range.vertexCount;\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue;\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      copyAttributeData(srcAttribute, dstAttribute, vertexStart);\n      const itemSize = srcAttribute.itemSize;\n      for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {\n        const index = vertexStart + i;\n        for (let c = 0; c < itemSize; c++) {\n          dstAttribute.setComponent(index, c, 0);\n        }\n      }\n      dstAttribute.needsUpdate = true;\n    }\n    this._vertexCounts[id] = srcPositionAttribute.count;\n    if (hasIndex) {\n      const indexStart = range.indexStart;\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));\n      }\n      for (let i = srcIndex.count, l = range.indexCount; i < l; i++) {\n        dstIndex.setX(indexStart + i, vertexStart);\n      }\n      dstIndex.needsUpdate = true;\n      this._indexCounts[id] = srcIndex.count;\n    }\n    return id;\n  }\n  deleteGeometry(geometryId) {\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= active.length || active[geometryId] === false) {\n      return this;\n    }\n    active[geometryId] = false;\n    _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n    matricesTexture.needsUpdate = true;\n    return this;\n  }\n  optimize() {\n    throw new Error(\"BatchedMesh: Optimize function not implemented.\");\n  }\n  setMatrixAt(geometryId, matrix) {\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return this;\n    }\n    if (visible[geometryId] === true) {\n      matrix.toArray(matricesArray, geometryId * 16);\n      matricesTexture.needsUpdate = true;\n    }\n    matrices[geometryId].copy(matrix);\n    return this;\n  }\n  getMatrixAt(geometryId, matrix) {\n    const matrices = this._matrices;\n    const active = this._active;\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return matrix;\n    }\n    return matrix.copy(matrices[geometryId]);\n  }\n  setVisibleAt(geometryId, value) {\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {\n      return this;\n    }\n    if (value === true) {\n      matrices[geometryId].toArray(matricesArray, geometryId * 16);\n    } else {\n      _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n    }\n    matricesTexture.needsUpdate = true;\n    visible[geometryId] = value;\n    return this;\n  }\n  getVisibleAt(geometryId) {\n    const visible = this._visible;\n    const active = this._active;\n    if (geometryId >= visible.length || active[geometryId] === false) {\n      return false;\n    }\n    return visible[geometryId];\n  }\n  raycast() {\n    console.warn(\"BatchedMesh: Raycast function not implemented.\");\n  }\n  copy() {\n    throw new Error(\"BatchedMesh: Copy function not implemented.\");\n  }\n  toJSON() {\n    throw new Error(\"BatchedMesh: toJSON function not implemented.\");\n  }\n  dispose() {\n    this.geometry.dispose();\n    this._matricesTexture.dispose();\n    this._matricesTexture = null;\n    return this;\n  }\n}\nexport {\n  BatchedMesh\n};\n//# sourceMappingURL=BatchedMesh.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}