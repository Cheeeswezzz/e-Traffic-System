{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Marcelo\\\\OneDrive\\\\Documents\\\\Desktop\\\\e-traffic system\\\\client\\\\src\\\\contexts\\\\NotificationContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { adminAPI } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationContext = /*#__PURE__*/createContext();\nexport const useNotifications = () => {\n  _s();\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n_s(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s2();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n\n  // Fetch notifications from the server\n  const {\n    refetch\n  } = useQuery({\n    queryKey: ['notifications'],\n    queryFn: () => adminAPI.getNotifications(),\n    refetchInterval: 60000,\n    // Refetch every 60 seconds as backup\n    onSuccess: data => {\n      if (data !== null && data !== void 0 && data.data) {\n        setNotifications(data.data);\n        setUnreadCount(data.data.filter(n => !n.read).length);\n      }\n    }\n  });\n\n  // WebSocket connection for real-time notifications\n  const connectWebSocket = () => {\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) return;\n\n      // Use WebSocket URL (adjust based on your server setup)\n      const wsUrl = process.env.NODE_ENV === 'production' ? `wss://${window.location.host}/ws/notifications?token=${token}` : `ws://localhost:5000/ws/notifications?token=${token}`;\n      wsRef.current = new WebSocket(wsUrl);\n      wsRef.current.onopen = () => {\n        console.log('WebSocket connected for notifications');\n        setIsConnected(true);\n        reconnectAttempts.current = 0;\n      };\n      wsRef.current.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          if (data.type === 'notification') {\n            // Add new notification\n            const newNotification = data.notification;\n            setNotifications(prev => {\n              // Check if notification already exists to avoid duplicates\n              const exists = prev.some(n => n.id === newNotification.id);\n              if (exists) return prev;\n              return [newNotification, ...prev];\n            });\n            if (!newNotification.read) {\n              setUnreadCount(prev => prev + 1);\n            }\n          } else if (data.type === 'notification_read') {\n            // Mark notification as read\n            setNotifications(prev => prev.map(n => n.id === data.notificationId ? {\n              ...n,\n              read: true\n            } : n));\n            setUnreadCount(prev => Math.max(0, prev - 1));\n          } else if (data.type === 'all_notifications_read') {\n            // Mark all notifications as read\n            setNotifications(prev => prev.map(n => ({\n              ...n,\n              read: true\n            })));\n            setUnreadCount(0);\n          }\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n      wsRef.current.onclose = () => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n\n        // Attempt to reconnect\n        if (reconnectAttempts.current < maxReconnectAttempts) {\n          reconnectAttempts.current++;\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            console.log(`Attempting to reconnect... (${reconnectAttempts.current}/${maxReconnectAttempts})`);\n            connectWebSocket();\n          }, delay);\n        }\n      };\n      wsRef.current.onerror = error => {\n        console.error('WebSocket error:', error);\n        setIsConnected(false);\n      };\n    } catch (error) {\n      console.error('Failed to connect WebSocket:', error);\n      setIsConnected(false);\n    }\n  };\n  const disconnectWebSocket = () => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    setIsConnected(false);\n  };\n\n  // Mark notification as read\n  const markAsRead = async notificationId => {\n    try {\n      await adminAPI.markNotificationAsRead(notificationId);\n      setNotifications(prev => prev.map(n => n.id === notificationId ? {\n        ...n,\n        read: true\n      } : n));\n      setUnreadCount(prev => Math.max(0, prev - 1));\n    } catch (error) {\n      console.error('Failed to mark notification as read:', error);\n    }\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = async () => {\n    try {\n      await adminAPI.markAllNotificationsAsRead();\n      setNotifications(prev => prev.map(n => ({\n        ...n,\n        read: true\n      })));\n      setUnreadCount(0);\n    } catch (error) {\n      console.error('Failed to mark all notifications as read:', error);\n    }\n  };\n\n  // Add a new notification (for real-time updates)\n  const addNotification = notification => {\n    setNotifications(prev => [notification, ...prev]);\n    if (!notification.read) {\n      setUnreadCount(prev => prev + 1);\n    }\n  };\n\n  // Connect WebSocket when component mounts\n  useEffect(() => {\n    const token = localStorage.getItem('token');\n    if (token) {\n      connectWebSocket();\n    }\n\n    // Cleanup on unmount\n    return () => {\n      disconnectWebSocket();\n    };\n  }, []);\n\n  // Reconnect WebSocket when token changes\n  useEffect(() => {\n    const token = localStorage.getItem('token');\n    if (token && !isConnected) {\n      connectWebSocket();\n    } else if (!token && isConnected) {\n      disconnectWebSocket();\n    }\n  }, [isConnected]);\n\n  // Handle page visibility changes\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        // Page is hidden, disconnect WebSocket to save resources\n        disconnectWebSocket();\n      } else {\n        // Page is visible, reconnect WebSocket\n        const token = localStorage.getItem('token');\n        if (token) {\n          connectWebSocket();\n        }\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, []);\n  const value = {\n    notifications,\n    unreadCount,\n    isOpen,\n    setIsOpen,\n    markAsRead,\n    markAllAsRead,\n    addNotification,\n    refetch,\n    isConnected\n  };\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 218,\n    columnNumber: 5\n  }, this);\n};\n_s2(NotificationProvider, \"b2GdRVLduOqFOV6ECBv9rUw/hoE=\", false, function () {\n  return [useQuery];\n});\n_c = NotificationProvider;\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useRef","useQuery","adminAPI","jsxDEV","_jsxDEV","NotificationContext","useNotifications","_s","context","Error","NotificationProvider","children","_s2","notifications","setNotifications","unreadCount","setUnreadCount","isOpen","setIsOpen","isConnected","setIsConnected","wsRef","reconnectTimeoutRef","reconnectAttempts","maxReconnectAttempts","refetch","queryKey","queryFn","getNotifications","refetchInterval","onSuccess","data","filter","n","read","length","connectWebSocket","token","localStorage","getItem","wsUrl","process","env","NODE_ENV","window","location","host","current","WebSocket","onopen","console","log","onmessage","event","JSON","parse","type","newNotification","notification","prev","exists","some","id","map","notificationId","Math","max","error","onclose","delay","min","pow","setTimeout","onerror","disconnectWebSocket","close","clearTimeout","markAsRead","markNotificationAsRead","markAllAsRead","markAllNotificationsAsRead","addNotification","handleVisibilityChange","document","hidden","addEventListener","removeEventListener","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Marcelo/OneDrive/Documents/Desktop/e-traffic system/client/src/contexts/NotificationContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useRef } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { adminAPI } from '../services/api';\r\n\r\nconst NotificationContext = createContext();\r\n\r\nexport const useNotifications = () => {\r\n  const context = useContext(NotificationContext);\r\n  if (!context) {\r\n    throw new Error('useNotifications must be used within a NotificationProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport const NotificationProvider = ({ children }) => {\r\n  const [notifications, setNotifications] = useState([]);\r\n  const [unreadCount, setUnreadCount] = useState(0);\r\n  const [isOpen, setIsOpen] = useState(false);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const wsRef = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const reconnectAttempts = useRef(0);\r\n  const maxReconnectAttempts = 5;\r\n\r\n  // Fetch notifications from the server\r\n  const { refetch } = useQuery({\r\n    queryKey: ['notifications'],\r\n    queryFn: () => adminAPI.getNotifications(),\r\n    refetchInterval: 60000, // Refetch every 60 seconds as backup\r\n    onSuccess: (data) => {\r\n      if (data?.data) {\r\n        setNotifications(data.data);\r\n        setUnreadCount(data.data.filter(n => !n.read).length);\r\n      }\r\n    }\r\n  });\r\n\r\n  // WebSocket connection for real-time notifications\r\n  const connectWebSocket = () => {\r\n    try {\r\n      const token = localStorage.getItem('token');\r\n      if (!token) return;\r\n\r\n      // Use WebSocket URL (adjust based on your server setup)\r\n      const wsUrl = process.env.NODE_ENV === 'production' \r\n        ? `wss://${window.location.host}/ws/notifications?token=${token}`\r\n        : `ws://localhost:5000/ws/notifications?token=${token}`;\r\n\r\n      wsRef.current = new WebSocket(wsUrl);\r\n\r\n      wsRef.current.onopen = () => {\r\n        console.log('WebSocket connected for notifications');\r\n        setIsConnected(true);\r\n        reconnectAttempts.current = 0;\r\n      };\r\n\r\n      wsRef.current.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          \r\n          if (data.type === 'notification') {\r\n            // Add new notification\r\n            const newNotification = data.notification;\r\n            setNotifications(prev => {\r\n              // Check if notification already exists to avoid duplicates\r\n              const exists = prev.some(n => n.id === newNotification.id);\r\n              if (exists) return prev;\r\n              \r\n              return [newNotification, ...prev];\r\n            });\r\n            \r\n            if (!newNotification.read) {\r\n              setUnreadCount(prev => prev + 1);\r\n            }\r\n          } else if (data.type === 'notification_read') {\r\n            // Mark notification as read\r\n            setNotifications(prev => \r\n              prev.map(n => n.id === data.notificationId ? { ...n, read: true } : n)\r\n            );\r\n            setUnreadCount(prev => Math.max(0, prev - 1));\r\n          } else if (data.type === 'all_notifications_read') {\r\n            // Mark all notifications as read\r\n            setNotifications(prev => prev.map(n => ({ ...n, read: true })));\r\n            setUnreadCount(0);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error parsing WebSocket message:', error);\r\n        }\r\n      };\r\n\r\n      wsRef.current.onclose = () => {\r\n        console.log('WebSocket disconnected');\r\n        setIsConnected(false);\r\n        \r\n        // Attempt to reconnect\r\n        if (reconnectAttempts.current < maxReconnectAttempts) {\r\n          reconnectAttempts.current++;\r\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);\r\n          \r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            console.log(`Attempting to reconnect... (${reconnectAttempts.current}/${maxReconnectAttempts})`);\r\n            connectWebSocket();\r\n          }, delay);\r\n        }\r\n      };\r\n\r\n      wsRef.current.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        setIsConnected(false);\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to connect WebSocket:', error);\r\n      setIsConnected(false);\r\n    }\r\n  };\r\n\r\n  const disconnectWebSocket = () => {\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n      wsRef.current = null;\r\n    }\r\n    if (reconnectTimeoutRef.current) {\r\n      clearTimeout(reconnectTimeoutRef.current);\r\n      reconnectTimeoutRef.current = null;\r\n    }\r\n    setIsConnected(false);\r\n  };\r\n\r\n  // Mark notification as read\r\n  const markAsRead = async (notificationId) => {\r\n    try {\r\n      await adminAPI.markNotificationAsRead(notificationId);\r\n      setNotifications(prev => \r\n        prev.map(n => n.id === notificationId ? { ...n, read: true } : n)\r\n      );\r\n      setUnreadCount(prev => Math.max(0, prev - 1));\r\n    } catch (error) {\r\n      console.error('Failed to mark notification as read:', error);\r\n    }\r\n  };\r\n\r\n  // Mark all notifications as read\r\n  const markAllAsRead = async () => {\r\n    try {\r\n      await adminAPI.markAllNotificationsAsRead();\r\n      setNotifications(prev => prev.map(n => ({ ...n, read: true })));\r\n      setUnreadCount(0);\r\n    } catch (error) {\r\n      console.error('Failed to mark all notifications as read:', error);\r\n    }\r\n  };\r\n\r\n  // Add a new notification (for real-time updates)\r\n  const addNotification = (notification) => {\r\n    setNotifications(prev => [notification, ...prev]);\r\n    if (!notification.read) {\r\n      setUnreadCount(prev => prev + 1);\r\n    }\r\n  };\r\n\r\n  // Connect WebSocket when component mounts\r\n  useEffect(() => {\r\n    const token = localStorage.getItem('token');\r\n    if (token) {\r\n      connectWebSocket();\r\n    }\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      disconnectWebSocket();\r\n    };\r\n  }, []);\r\n\r\n  // Reconnect WebSocket when token changes\r\n  useEffect(() => {\r\n    const token = localStorage.getItem('token');\r\n    if (token && !isConnected) {\r\n      connectWebSocket();\r\n    } else if (!token && isConnected) {\r\n      disconnectWebSocket();\r\n    }\r\n  }, [isConnected]);\r\n\r\n  // Handle page visibility changes\r\n  useEffect(() => {\r\n    const handleVisibilityChange = () => {\r\n      if (document.hidden) {\r\n        // Page is hidden, disconnect WebSocket to save resources\r\n        disconnectWebSocket();\r\n      } else {\r\n        // Page is visible, reconnect WebSocket\r\n        const token = localStorage.getItem('token');\r\n        if (token) {\r\n          connectWebSocket();\r\n        }\r\n      }\r\n    };\r\n\r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n    return () => {\r\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n    };\r\n  }, []);\r\n\r\n  const value = {\r\n    notifications,\r\n    unreadCount,\r\n    isOpen,\r\n    setIsOpen,\r\n    markAsRead,\r\n    markAllAsRead,\r\n    addNotification,\r\n    refetch,\r\n    isConnected\r\n  };\r\n\r\n  return (\r\n    <NotificationContext.Provider value={value}>\r\n      {children}\r\n    </NotificationContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}