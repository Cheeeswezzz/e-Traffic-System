{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Mesh, Points } from \"three\";\nconst DRACOExporter = /* @__PURE__ */(() => {\n  const _DRACOExporter = class {\n    parse(object, options = {\n      decodeSpeed: 5,\n      encodeSpeed: 5,\n      encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n      quantization: [16, 8, 8, 8, 8],\n      exportUvs: true,\n      exportNormals: true,\n      exportColor: false\n    }) {\n      if (object instanceof BufferGeometry && object.isBufferGeometry) {\n        throw new Error(\"DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.\");\n      }\n      if (DracoEncoderModule === void 0) {\n        throw new Error(\"THREE.DRACOExporter: required the draco_encoder to work.\");\n      }\n      const geometry = object.geometry;\n      const dracoEncoder = DracoEncoderModule();\n      const encoder = new dracoEncoder.Encoder();\n      let builder;\n      let dracoObject;\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\"THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.\");\n      }\n      if (object instanceof Mesh && object.isMesh) {\n        builder = new dracoEncoder.MeshBuilder();\n        dracoObject = new dracoEncoder.Mesh();\n        const vertices = geometry.getAttribute(\"position\");\n        builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n        const faces = geometry.getIndex();\n        if (faces !== null) {\n          builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n        } else {\n          const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n          for (let i = 0; i < faces2.length; i++) {\n            faces2[i] = i;\n          }\n          builder.AddFacesToMesh(dracoObject, vertices.count, faces2);\n        }\n        if (options.exportNormals) {\n          const normals = geometry.getAttribute(\"normal\");\n          if (normals !== void 0) {\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n          }\n        }\n        if (options.exportUvs) {\n          const uvs = geometry.getAttribute(\"uv\");\n          if (uvs !== void 0) {\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n          }\n        }\n        if (options.exportColor) {\n          const colors = geometry.getAttribute(\"color\");\n          if (colors !== void 0) {\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n          }\n        }\n      } else if (object instanceof Points && object.isPoints) {\n        builder = new dracoEncoder.PointCloudBuilder();\n        dracoObject = new dracoEncoder.PointCloud();\n        const vertices = geometry.getAttribute(\"position\");\n        builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n        if (options.exportColor) {\n          const colors = geometry.getAttribute(\"color\");\n          if (colors !== void 0) {\n            builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n          }\n        }\n      } else {\n        throw new Error(\"DRACOExporter: Unsupported object type.\");\n      }\n      const encodedData = new dracoEncoder.DracoInt8Array();\n      const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;\n      const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;\n      encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);\n      if (options.encoderMethod !== void 0) {\n        encoder.SetEncodingMethod(options.encoderMethod);\n      }\n      if (options.quantization !== void 0) {\n        for (let i = 0; i < 5; i++) {\n          if (options.quantization[i] !== void 0) {\n            encoder.SetAttributeQuantization(i, options.quantization[i]);\n          }\n        }\n      }\n      let length;\n      if (object instanceof Mesh && object.isMesh) {\n        length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n      } else {\n        length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n      }\n      dracoEncoder.destroy(dracoObject);\n      if (length === 0) {\n        throw new Error(\"THREE.DRACOExporter: Draco encoding failed.\");\n      }\n      const outputData = new Int8Array(new ArrayBuffer(length));\n      for (let i = 0; i < length; i++) {\n        outputData[i] = encodedData.GetValue(i);\n      }\n      dracoEncoder.destroy(encodedData);\n      dracoEncoder.destroy(encoder);\n      dracoEncoder.destroy(builder);\n      return outputData;\n    }\n  };\n  let DRACOExporter2 = _DRACOExporter;\n  // Encoder methods\n  __publicField(DRACOExporter2, \"MESH_EDGEBREAKER_ENCODING\", 1);\n  __publicField(DRACOExporter2, \"MESH_SEQUENTIAL_ENCODING\", 0);\n  // Geometry type\n  __publicField(DRACOExporter2, \"POINT_CLOUD\", 0);\n  __publicField(DRACOExporter2, \"TRIANGULAR_MESH\", 1);\n  // Attribute type\n  __publicField(DRACOExporter2, \"INVALID\", -1);\n  __publicField(DRACOExporter2, \"POSITION\", 0);\n  __publicField(DRACOExporter2, \"NORMAL\", 1);\n  __publicField(DRACOExporter2, \"COLOR\", 2);\n  __publicField(DRACOExporter2, \"TEX_COORD\", 3);\n  __publicField(DRACOExporter2, \"GENERIC\", 4);\n  return DRACOExporter2;\n})();\nexport { DRACOExporter };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","BufferGeometry","Mesh","Points","DRACOExporter","_DRACOExporter","parse","object","options","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","isBufferGeometry","Error","DracoEncoderModule","geometry","dracoEncoder","encoder","Encoder","builder","dracoObject","isMesh","MeshBuilder","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","faces2","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","COLOR","isPoints","PointCloudBuilder","PointCloud","AddFloatAttribute","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","EncodePointCloudToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue","DRACOExporter2"],"sources":["C:/Users/Marcelo/OneDrive/Documents/Desktop/e-traffic system/client/node_modules/three-stdlib/exporters/DRACOExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Mesh, Points } from \"three\";\nconst DRACOExporter = /* @__PURE__ */ (() => {\n  const _DRACOExporter = class {\n    parse(object, options = {\n      decodeSpeed: 5,\n      encodeSpeed: 5,\n      encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n      quantization: [16, 8, 8, 8, 8],\n      exportUvs: true,\n      exportNormals: true,\n      exportColor: false\n    }) {\n      if (object instanceof BufferGeometry && object.isBufferGeometry) {\n        throw new Error(\"DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.\");\n      }\n      if (DracoEncoderModule === void 0) {\n        throw new Error(\"THREE.DRACOExporter: required the draco_encoder to work.\");\n      }\n      const geometry = object.geometry;\n      const dracoEncoder = DracoEncoderModule();\n      const encoder = new dracoEncoder.Encoder();\n      let builder;\n      let dracoObject;\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\n          \"THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.\"\n        );\n      }\n      if (object instanceof Mesh && object.isMesh) {\n        builder = new dracoEncoder.MeshBuilder();\n        dracoObject = new dracoEncoder.Mesh();\n        const vertices = geometry.getAttribute(\"position\");\n        builder.AddFloatAttributeToMesh(\n          dracoObject,\n          dracoEncoder.POSITION,\n          vertices.count,\n          vertices.itemSize,\n          vertices.array\n        );\n        const faces = geometry.getIndex();\n        if (faces !== null) {\n          builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n        } else {\n          const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n          for (let i = 0; i < faces2.length; i++) {\n            faces2[i] = i;\n          }\n          builder.AddFacesToMesh(dracoObject, vertices.count, faces2);\n        }\n        if (options.exportNormals) {\n          const normals = geometry.getAttribute(\"normal\");\n          if (normals !== void 0) {\n            builder.AddFloatAttributeToMesh(\n              dracoObject,\n              dracoEncoder.NORMAL,\n              normals.count,\n              normals.itemSize,\n              normals.array\n            );\n          }\n        }\n        if (options.exportUvs) {\n          const uvs = geometry.getAttribute(\"uv\");\n          if (uvs !== void 0) {\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n          }\n        }\n        if (options.exportColor) {\n          const colors = geometry.getAttribute(\"color\");\n          if (colors !== void 0) {\n            builder.AddFloatAttributeToMesh(\n              dracoObject,\n              dracoEncoder.COLOR,\n              colors.count,\n              colors.itemSize,\n              colors.array\n            );\n          }\n        }\n      } else if (object instanceof Points && object.isPoints) {\n        builder = new dracoEncoder.PointCloudBuilder();\n        dracoObject = new dracoEncoder.PointCloud();\n        const vertices = geometry.getAttribute(\"position\");\n        builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n        if (options.exportColor) {\n          const colors = geometry.getAttribute(\"color\");\n          if (colors !== void 0) {\n            builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n          }\n        }\n      } else {\n        throw new Error(\"DRACOExporter: Unsupported object type.\");\n      }\n      const encodedData = new dracoEncoder.DracoInt8Array();\n      const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;\n      const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;\n      encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);\n      if (options.encoderMethod !== void 0) {\n        encoder.SetEncodingMethod(options.encoderMethod);\n      }\n      if (options.quantization !== void 0) {\n        for (let i = 0; i < 5; i++) {\n          if (options.quantization[i] !== void 0) {\n            encoder.SetAttributeQuantization(i, options.quantization[i]);\n          }\n        }\n      }\n      let length;\n      if (object instanceof Mesh && object.isMesh) {\n        length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n      } else {\n        length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n      }\n      dracoEncoder.destroy(dracoObject);\n      if (length === 0) {\n        throw new Error(\"THREE.DRACOExporter: Draco encoding failed.\");\n      }\n      const outputData = new Int8Array(new ArrayBuffer(length));\n      for (let i = 0; i < length; i++) {\n        outputData[i] = encodedData.GetValue(i);\n      }\n      dracoEncoder.destroy(encodedData);\n      dracoEncoder.destroy(encoder);\n      dracoEncoder.destroy(builder);\n      return outputData;\n    }\n  };\n  let DRACOExporter2 = _DRACOExporter;\n  // Encoder methods\n  __publicField(DRACOExporter2, \"MESH_EDGEBREAKER_ENCODING\", 1);\n  __publicField(DRACOExporter2, \"MESH_SEQUENTIAL_ENCODING\", 0);\n  // Geometry type\n  __publicField(DRACOExporter2, \"POINT_CLOUD\", 0);\n  __publicField(DRACOExporter2, \"TRIANGULAR_MESH\", 1);\n  // Attribute type\n  __publicField(DRACOExporter2, \"INVALID\", -1);\n  __publicField(DRACOExporter2, \"POSITION\", 0);\n  __publicField(DRACOExporter2, \"NORMAL\", 1);\n  __publicField(DRACOExporter2, \"COLOR\", 2);\n  __publicField(DRACOExporter2, \"TEX_COORD\", 3);\n  __publicField(DRACOExporter2, \"GENERIC\", 4);\n  return DRACOExporter2;\n})();\nexport {\n  DRACOExporter\n};\n//# sourceMappingURL=DRACOExporter.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}