{"ast":null,"code":"import { Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, Vector4, Vector3, Box3, Sphere, MathUtils, Matrix4, Line3 } from \"three\";\nimport { LineSegmentsGeometry } from \"./LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"./LineMaterial.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nconst _viewport = /* @__PURE__ */new Vector4();\nconst _start = /* @__PURE__ */new Vector3();\nconst _end = /* @__PURE__ */new Vector3();\nconst _start4 = /* @__PURE__ */new Vector4();\nconst _end4 = /* @__PURE__ */new Vector4();\nconst _ssOrigin = /* @__PURE__ */new Vector4();\nconst _ssOrigin3 = /* @__PURE__ */new Vector3();\nconst _mvMatrix = /* @__PURE__ */new Matrix4();\nconst _line = /* @__PURE__ */new Line3();\nconst _closestPoint = /* @__PURE__ */new Vector3();\nconst _box = /* @__PURE__ */new Box3();\nconst _sphere = /* @__PURE__ */new Sphere();\nconst _clipToWorldVector = /* @__PURE__ */new Vector4();\nlet _ray, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i);\n    _line.end.fromBufferAttribute(instanceEnd, i);\n    _line.applyMatrix4(matrixWorld);\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  const near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n      _end4.lerp(_start4, t);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null\n      });\n    }\n  }\n}\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 16777215\n  })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);\n    geometry.setAttribute(\"instanceDistanceStart\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n    geometry.setAttribute(\"instanceDistanceEnd\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    let sphereMargin;\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n    _sphere.radius += sphereMargin;\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    let boxMargin;\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n    _box.expandByScalar(boxMargin);\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms;\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n    }\n  }\n}\nexport { LineSegments2 };","map":{"version":3,"names":["Mesh","InstancedInterleavedBuffer","InterleavedBufferAttribute","Vector4","Vector3","Box3","Sphere","MathUtils","Matrix4","Line3","LineSegmentsGeometry","LineMaterial","UV1","_viewport","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","matrixWorld","geometry","instanceStart","attributes","instanceEnd","segmentCount","min","instanceCount","count","i","l","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","isInside","distanceTo","push","origin","object","face","faceIndex","uv","raycastScreenSpace","material","near","at","matrixWorldInverse","z","copy","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","LineSegments2","constructor","color","random","isLineSegments2","type","computeLineDistances","lineDistances","Float32Array","j","instanceDistanceBuffer","setAttribute","raycast","raycaster","worldUnits","console","error","threshold","params","Line2","ray","linewidth","boundingSphere","computeBoundingSphere","sphereMargin","distanceToSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","boxMargin","distanceToBox","expandByScalar","intersectsBox","onBeforeRender","renderer","uniforms","getViewport","value"],"sources":["C:/Users/Marcelo/OneDrive/Documents/Desktop/e-traffic system/client/node_modules/three-stdlib/lines/LineSegments2.js"],"sourcesContent":["import { Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, Vector4, Vector3, Box3, Sphere, MathUtils, Matrix4, Line3 } from \"three\";\nimport { LineSegmentsGeometry } from \"./LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"./LineMaterial.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nconst _viewport = /* @__PURE__ */ new Vector4();\nconst _start = /* @__PURE__ */ new Vector3();\nconst _end = /* @__PURE__ */ new Vector3();\nconst _start4 = /* @__PURE__ */ new Vector4();\nconst _end4 = /* @__PURE__ */ new Vector4();\nconst _ssOrigin = /* @__PURE__ */ new Vector4();\nconst _ssOrigin3 = /* @__PURE__ */ new Vector3();\nconst _mvMatrix = /* @__PURE__ */ new Matrix4();\nconst _line = /* @__PURE__ */ new Line3();\nconst _closestPoint = /* @__PURE__ */ new Vector3();\nconst _box = /* @__PURE__ */ new Box3();\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst _clipToWorldVector = /* @__PURE__ */ new Vector4();\nlet _ray, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i);\n    _line.end.fromBufferAttribute(instanceEnd, i);\n    _line.applyMatrix4(matrixWorld);\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  const near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n      _end4.lerp(_start4, t);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null\n      });\n    }\n  }\n}\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);\n    geometry.setAttribute(\"instanceDistanceStart\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n    geometry.setAttribute(\"instanceDistanceEnd\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n    return this;\n  }\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'\n      );\n    }\n    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    let sphereMargin;\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n    _sphere.radius += sphereMargin;\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    let boxMargin;\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n    _box.expandByScalar(boxMargin);\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms;\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n    }\n  }\n}\nexport {\n  LineSegments2\n};\n//# sourceMappingURL=LineSegments2.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}