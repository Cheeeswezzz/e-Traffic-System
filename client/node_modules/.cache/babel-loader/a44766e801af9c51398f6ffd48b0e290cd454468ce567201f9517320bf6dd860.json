{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from \"three\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nclass ColladaExporter {\n  constructor() {\n    __publicField(this, \"options\");\n    __publicField(this, \"geometryInfo\");\n    __publicField(this, \"materialMap\");\n    __publicField(this, \"imageMap\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"libraryImages\");\n    __publicField(this, \"libraryGeometries\");\n    __publicField(this, \"libraryEffects\");\n    __publicField(this, \"libraryMaterials\");\n    __publicField(this, \"canvas\");\n    __publicField(this, \"ctx\");\n    __publicField(this, \"transMat\");\n    __publicField(this, \"getFuncs\", [\"getX\", \"getY\", \"getZ\", \"getW\"]);\n    this.options = {\n      version: \"1.4.1\",\n      author: null,\n      textureDirectory: \"\",\n      upAxis: \"Y_UP\",\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = /* @__PURE__ */new WeakMap();\n    this.materialMap = /* @__PURE__ */new WeakMap();\n    this.imageMap = /* @__PURE__ */new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n  parse(object, onDone, options = {}) {\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error(\"ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.\");\n      return null;\n    }\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error(\"ColladaExporter: unitMeter needs to be specified if unitName is specified.\");\n      return null;\n    }\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error(\"ColladaExporter: unitName needs to be specified if unitMeter is specified.\");\n      return null;\n    }\n    if (this.options.textureDirectory !== \"\") {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\");\n    }\n    if (this.options.version !== \"1.4.1\" && this.options.version !== \"1.5.0\") {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    }\n    const libraryVisualScenes = this.processObject(object);\n    const specLink = this.options.version === \"1.4.1\" ? \"http://www.collada.org/2005/11/COLLADASchema\" : \"https://www.khronos.org/collada/\";\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : \"\"}</contributor>${`<created>${(/* @__PURE__ */new Date()).toISOString()}</created>`}${`<modified>${(/* @__PURE__ */new Date()).toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${this.libraryImages.join(\"\")}</library_images>`;\n    dae += `<library_effects>${this.libraryEffects.join(\"\")}</library_effects>`;\n    dae += `<library_materials>${this.libraryMaterials.join(\"\")}</library_materials>`;\n    dae += `<library_geometries>${this.libraryGeometries.join(\"\")}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += \"</COLLADA>\";\n    const res = {\n      data: this.format(dae),\n      textures: this.textures\n    };\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone(res));\n    }\n    return res;\n  }\n  // Convert the urdf xml into a well-formatted, indented format\n  format(urdf) {\n    var _a, _b;\n    const IS_END_TAG = /^<\\//;\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n    const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : \"\";\n    let tagnum = 0;\n    return (_b = (_a = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) == null ? void 0 : _a.map(tag => {\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n        tagnum--;\n      }\n      const res = `${pad(\"  \", tagnum)}${tag}`;\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n        tagnum++;\n      }\n      return res;\n    }).join(\"\\n\")) != null ? _b : \"\";\n  }\n  // Convert an image into a png format for saving\n  base64ToBuffer(str) {\n    const b = atob(str);\n    const buf = new Uint8Array(b.length);\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i);\n    }\n    return buf;\n  }\n  imageToData(image, ext) {\n    var _a;\n    this.canvas = this.canvas || document.createElement(\"canvas\");\n    this.ctx = this.ctx || this.canvas.getContext(\"2d\");\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n    (_a = this.ctx) == null ? void 0 : _a.drawImage(image, 0, 0);\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, \"\");\n    return this.base64ToBuffer(base64data);\n  }\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  attrBufferToArray(attr) {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      const TypedArrayConstructor = attr.array.constructor;\n      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n      const size = attr.itemSize;\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i);\n        }\n      }\n      return arr;\n    } else {\n      return attr.array;\n    }\n  }\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  subArray(arr, st, ct) {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct);\n    } else {\n      const TypedArrayConstructor = arr.constructor;\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    }\n  }\n  // Returns the string for a geometry's attribute\n  getAttribute(attr, name, params, type) {\n    const array = this.attrBufferToArray(attr);\n    const res = Array.isArray(array) ? `${`<source id=\"${name}\"><float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(\" \")}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(array.length / attr.itemSize)}\" stride=\"${attr.itemSize}\">`}${params.map(n => `<param name=\"${n}\" type=\"${type}\" />`).join(\"\")}</accessor></technique_common></source>` : \"\";\n    return res;\n  }\n  // Returns the string for a node's transform information\n  getTransform(o) {\n    o.updateMatrix();\n    this.transMat = this.transMat || new Matrix4();\n    this.transMat.copy(o.matrix);\n    this.transMat.transpose();\n    return `<matrix>${this.transMat.toArray().join(\" \")}</matrix>`;\n  }\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  processGeometry(g) {\n    let info = this.geometryInfo.get(g);\n    if (!info) {\n      const bufferGeometry = g;\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error(\"THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`;\n      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n        start: 0,\n        count: indexCount,\n        materialIndex: 0\n      }];\n      const gname = g.name ? ` name=\"${g.name}\"` : \"\";\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`;\n      const posName = `${meshid}-position`;\n      const vertName = `${meshid}-vertices`;\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, [\"X\", \"Y\", \"Z\"], \"float\");\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`;\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n      if (\"normal\" in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`;\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, [\"X\", \"Y\", \"Z\"], \"float\");\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n      }\n      if (\"uv\" in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n      }\n      if (UV1 in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`;\n        gnode += this.getAttribute(bufferGeometry.attributes[UV1], uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n      }\n      if (\"color\" in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`;\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, [\"X\", \"Y\", \"Z\"], \"uint8\");\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n      }\n      let indexArray = null;\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index);\n      } else {\n        indexArray = new Array(indexCount);\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i;\n      }\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i];\n        const subarr = this.subArray(indexArray, group.start, group.count);\n        const polycount = subarr.length / 3;\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n        gnode += triangleInputs;\n        gnode += `<p>${subarr.join(\" \")}</p>`;\n        gnode += \"</triangles>\";\n      }\n      gnode += \"</mesh></geometry>\";\n      this.libraryGeometries.push(gnode);\n      info = {\n        meshid,\n        bufferGeometry\n      };\n      this.geometryInfo.set(g, info);\n    }\n    return info;\n  }\n  // Process the given texture into the image library\n  // Returns the image library\n  processTexture(tex) {\n    let texid = this.imageMap.get(tex);\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`;\n      const ext = \"png\";\n      const name = tex.name || texid;\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n      if (this.options.version === \"1.5.0\") {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;\n      } else {\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;\n      }\n      imageNode += \"</image>\";\n      this.libraryImages.push(imageNode);\n      this.imageMap.set(tex, texid);\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex\n      });\n    }\n    return texid;\n  }\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  processMaterial(m) {\n    let matid = this.materialMap.get(m);\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`;\n      let type = \"phong\";\n      if (m instanceof MeshLambertMaterial) {\n        type = \"lambert\";\n      } else if (m instanceof MeshBasicMaterial) {\n        type = \"constant\";\n        if (m.map !== null) {\n          console.warn(\"ColladaExporter: Texture maps not supported with MeshBasicMaterial.\");\n        }\n      }\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0;\n        let transparencyNode = \"\";\n        if (m.transparent) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : \"<float>1</float>\"}</transparent>`;\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== \"constant\" ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : \"\"}${type !== \"constant\" ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : \"\"}</bump>` : \"\"}${type === \"phong\" ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : \"\"}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.map)}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : \"\"}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.specularMap)}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : \"\"}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.emissiveMap)}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : \"\"}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(m.normalMap)}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : \"\"}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : \"\"}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : \"\";\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        this.libraryMaterials.push(materialNode);\n        this.libraryEffects.push(effectnode);\n        this.materialMap.set(m, matid);\n      }\n    }\n    return matid;\n  }\n  // Recursively process the object into a scene\n  processObject(o) {\n    let node = `<node name=\"${o.name}\">`;\n    node += this.getTransform(o);\n    const a = new Mesh();\n    a.geometry;\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      const geomInfo = this.processGeometry(o.geometry);\n      const meshid = geomInfo.meshid;\n      const geometry = geomInfo.bufferGeometry;\n      let matids = null;\n      let matidsArray;\n      const mat = o.material || new MeshBasicMaterial();\n      const materials = Array.isArray(mat) ? mat : [mat];\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length);\n      } else {\n        matidsArray = new Array(materials.length);\n      }\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]));\n      node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map((id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`).join(\"\")}</technique_common></bind_material>` : \"\")}</instance_geometry>`;\n    }\n    o.children.forEach(c => node += this.processObject(c));\n    node += \"</node>\";\n    return node;\n  }\n}\nexport { ColladaExporter };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","InterleavedBufferAttribute","Matrix4","MeshLambertMaterial","MeshBasicMaterial","MeshPhongMaterial","Color","DoubleSide","Mesh","UV1","ColladaExporter","constructor","options","version","author","textureDirectory","upAxis","unitName","unitMeter","geometryInfo","WeakMap","materialMap","imageMap","textures","libraryImages","libraryGeometries","libraryEffects","libraryMaterials","canvas","ctx","transMat","parse","object","onDone","match","console","error","replace","warn","libraryVisualScenes","processObject","specLink","dae","Date","toISOString","join","res","data","format","requestAnimationFrame","urdf","_a","_b","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","ch","num","tagnum","map","tag","test","base64ToBuffer","str","b","atob","buf","Uint8Array","length","i","l","charCodeAt","imageToData","image","ext","document","createElement","getContext","width","SVGAnimatedLength","height","drawImage","base64data","toDataURL","attrBufferToArray","attr","isInterleavedBufferAttribute","TypedArrayConstructor","array","arr","count","itemSize","size","j","getFuncs","subArray","st","ct","Array","isArray","slice","buffer","BYTES_PER_ELEMENT","getAttribute","name","params","type","Math","floor","n","getTransform","o","updateMatrix","copy","matrix","transpose","toArray","processGeometry","g","info","get","bufferGeometry","isBufferGeometry","Error","meshid","indexCount","index","attributes","position","groups","start","materialIndex","gname","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","colName","color","indexArray","group","subarr","polycount","push","set","processTexture","tex","texid","imageNode","directory","original","processMaterial","m","matid","emissive","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","r","normalMap","specularMap","effectnode","side","materialName","materialNode","node","a","geometry","isMesh","geomInfo","matids","matidsArray","mat","material","materials","fill","_","id","children","forEach","c"],"sources":["C:/Users/Marcelo/OneDrive/Documents/Desktop/e-traffic system/client/node_modules/three-stdlib/exporters/ColladaExporter.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from \"three\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nclass ColladaExporter {\n  constructor() {\n    __publicField(this, \"options\");\n    __publicField(this, \"geometryInfo\");\n    __publicField(this, \"materialMap\");\n    __publicField(this, \"imageMap\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"libraryImages\");\n    __publicField(this, \"libraryGeometries\");\n    __publicField(this, \"libraryEffects\");\n    __publicField(this, \"libraryMaterials\");\n    __publicField(this, \"canvas\");\n    __publicField(this, \"ctx\");\n    __publicField(this, \"transMat\");\n    __publicField(this, \"getFuncs\", [\"getX\", \"getY\", \"getZ\", \"getW\"]);\n    this.options = {\n      version: \"1.4.1\",\n      author: null,\n      textureDirectory: \"\",\n      upAxis: \"Y_UP\",\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = /* @__PURE__ */ new WeakMap();\n    this.materialMap = /* @__PURE__ */ new WeakMap();\n    this.imageMap = /* @__PURE__ */ new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n  parse(object, onDone, options = {}) {\n    this.options = { ...this.options, ...options };\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error(\"ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.\");\n      return null;\n    }\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error(\"ColladaExporter: unitMeter needs to be specified if unitName is specified.\");\n      return null;\n    }\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error(\"ColladaExporter: unitName needs to be specified if unitMeter is specified.\");\n      return null;\n    }\n    if (this.options.textureDirectory !== \"\") {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\");\n    }\n    if (this.options.version !== \"1.4.1\" && this.options.version !== \"1.5.0\") {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`);\n      return null;\n    }\n    const libraryVisualScenes = this.processObject(object);\n    const specLink = this.options.version === \"1.4.1\" ? \"http://www.collada.org/2005/11/COLLADASchema\" : \"https://www.khronos.org/collada/\";\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${this.options.author !== null ? `<author>${this.options.author}</author>` : \"\"}</contributor>${`<created>${(/* @__PURE__ */ new Date()).toISOString()}</created>`}${`<modified>${(/* @__PURE__ */ new Date()).toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`;\n    dae += `<library_images>${this.libraryImages.join(\"\")}</library_images>`;\n    dae += `<library_effects>${this.libraryEffects.join(\"\")}</library_effects>`;\n    dae += `<library_materials>${this.libraryMaterials.join(\"\")}</library_materials>`;\n    dae += `<library_geometries>${this.libraryGeometries.join(\"\")}</library_geometries>`;\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`;\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += \"</COLLADA>\";\n    const res = {\n      data: this.format(dae),\n      textures: this.textures\n    };\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone(res));\n    }\n    return res;\n  }\n  // Convert the urdf xml into a well-formatted, indented format\n  format(urdf) {\n    var _a, _b;\n    const IS_END_TAG = /^<\\//;\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n    const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : \"\";\n    let tagnum = 0;\n    return (_b = (_a = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) == null ? void 0 : _a.map((tag) => {\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n        tagnum--;\n      }\n      const res = `${pad(\"  \", tagnum)}${tag}`;\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n        tagnum++;\n      }\n      return res;\n    }).join(\"\\n\")) != null ? _b : \"\";\n  }\n  // Convert an image into a png format for saving\n  base64ToBuffer(str) {\n    const b = atob(str);\n    const buf = new Uint8Array(b.length);\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i);\n    }\n    return buf;\n  }\n  imageToData(image, ext) {\n    var _a;\n    this.canvas = this.canvas || document.createElement(\"canvas\");\n    this.ctx = this.ctx || this.canvas.getContext(\"2d\");\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n    (_a = this.ctx) == null ? void 0 : _a.drawImage(image, 0, 0);\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, \"\");\n    return this.base64ToBuffer(base64data);\n  }\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  attrBufferToArray(attr) {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      const TypedArrayConstructor = attr.array.constructor;\n      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n      const size = attr.itemSize;\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i);\n        }\n      }\n      return arr;\n    } else {\n      return attr.array;\n    }\n  }\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  subArray(arr, st, ct) {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct);\n    } else {\n      const TypedArrayConstructor = arr.constructor;\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    }\n  }\n  // Returns the string for a geometry's attribute\n  getAttribute(attr, name, params, type) {\n    const array = this.attrBufferToArray(attr);\n    const res = Array.isArray(array) ? `${`<source id=\"${name}\"><float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(\" \")}</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(\n      array.length / attr.itemSize\n    )}\" stride=\"${attr.itemSize}\">`}${params.map((n) => `<param name=\"${n}\" type=\"${type}\" />`).join(\"\")}</accessor></technique_common></source>` : \"\";\n    return res;\n  }\n  // Returns the string for a node's transform information\n  getTransform(o) {\n    o.updateMatrix();\n    this.transMat = this.transMat || new Matrix4();\n    this.transMat.copy(o.matrix);\n    this.transMat.transpose();\n    return `<matrix>${this.transMat.toArray().join(\" \")}</matrix>`;\n  }\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  processGeometry(g) {\n    let info = this.geometryInfo.get(g);\n    if (!info) {\n      const bufferGeometry = g;\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error(\"THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`;\n      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{ start: 0, count: indexCount, materialIndex: 0 }];\n      const gname = g.name ? ` name=\"${g.name}\"` : \"\";\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`;\n      const posName = `${meshid}-position`;\n      const vertName = `${meshid}-vertices`;\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, [\"X\", \"Y\", \"Z\"], \"float\");\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`;\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`;\n      if (\"normal\" in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`;\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, [\"X\", \"Y\", \"Z\"], \"float\");\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`;\n      }\n      if (\"uv\" in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`;\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`;\n      }\n      if (UV1 in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`;\n        gnode += this.getAttribute(bufferGeometry.attributes[UV1], uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`;\n      }\n      if (\"color\" in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`;\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, [\"X\", \"Y\", \"Z\"], \"uint8\");\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`;\n      }\n      let indexArray = null;\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index);\n      } else {\n        indexArray = new Array(indexCount);\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++)\n          indexArray[i] = i;\n      }\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i];\n        const subarr = this.subArray(indexArray, group.start, group.count);\n        const polycount = subarr.length / 3;\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`;\n        gnode += triangleInputs;\n        gnode += `<p>${subarr.join(\" \")}</p>`;\n        gnode += \"</triangles>\";\n      }\n      gnode += \"</mesh></geometry>\";\n      this.libraryGeometries.push(gnode);\n      info = { meshid, bufferGeometry };\n      this.geometryInfo.set(g, info);\n    }\n    return info;\n  }\n  // Process the given texture into the image library\n  // Returns the image library\n  processTexture(tex) {\n    let texid = this.imageMap.get(tex);\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`;\n      const ext = \"png\";\n      const name = tex.name || texid;\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`;\n      if (this.options.version === \"1.5.0\") {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`;\n      } else {\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`;\n      }\n      imageNode += \"</image>\";\n      this.libraryImages.push(imageNode);\n      this.imageMap.set(tex, texid);\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex\n      });\n    }\n    return texid;\n  }\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  processMaterial(m) {\n    let matid = this.materialMap.get(m);\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`;\n      let type = \"phong\";\n      if (m instanceof MeshLambertMaterial) {\n        type = \"lambert\";\n      } else if (m instanceof MeshBasicMaterial) {\n        type = \"constant\";\n        if (m.map !== null) {\n          console.warn(\"ColladaExporter: Texture maps not supported with MeshBasicMaterial.\");\n        }\n      }\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0;\n        let transparencyNode = \"\";\n        if (m.transparent) {\n          transparencyNode += `<transparent>${m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : \"<float>1</float>\"}</transparent>`;\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`;\n          }\n        }\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`}</emission>${type !== \"constant\" ? `<diffuse>${m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`}</diffuse>` : \"\"}${type !== \"constant\" ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : \"\"}</bump>` : \"\"}${type === \"phong\" ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${shininess}</float>`}</shininess>` : \"\"}${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`;\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${m.map ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n          m.map\n        )}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>` : \"\"}${m.specularMap ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n          m.specularMap\n        )}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>` : \"\"}${m.emissiveMap ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n          m.emissiveMap\n        )}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>` : \"\"}${m.normalMap ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n          m.normalMap\n        )}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>` : \"\"}${techniqueNode}${m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : \"\"}</profile_COMMON></effect>`;\n        const materialName = m.name ? ` name=\"${m.name}\"` : \"\";\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`;\n        this.libraryMaterials.push(materialNode);\n        this.libraryEffects.push(effectnode);\n        this.materialMap.set(m, matid);\n      }\n    }\n    return matid;\n  }\n  // Recursively process the object into a scene\n  processObject(o) {\n    let node = `<node name=\"${o.name}\">`;\n    node += this.getTransform(o);\n    const a = new Mesh();\n    a.geometry;\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      const geomInfo = this.processGeometry(o.geometry);\n      const meshid = geomInfo.meshid;\n      const geometry = geomInfo.bufferGeometry;\n      let matids = null;\n      let matidsArray;\n      const mat = o.material || new MeshBasicMaterial();\n      const materials = Array.isArray(mat) ? mat : [mat];\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length);\n      } else {\n        matidsArray = new Array(materials.length);\n      }\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]));\n      node += `${`<instance_geometry url=\"#${meshid}\">` + (matids != null ? `<bind_material><technique_common>${matids.map(\n        (id, i) => `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`\n      ).join(\"\")}</technique_common></bind_material>` : \"\")}</instance_geometry>`;\n    }\n    o.children.forEach((c) => node += this.processObject(c));\n    node += \"</node>\";\n    return node;\n  }\n}\nexport {\n  ColladaExporter\n};\n//# sourceMappingURL=ColladaExporter.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}