{"ast":null,"code":"import { InstancedBufferGeometry, Float32BufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute, WireframeGeometry, Box3, Sphere, Vector3 } from \"three\";\nconst _box = /* @__PURE__ */new Box3();\nconst _vector = /* @__PURE__ */new Vector3();\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.isLineSegmentsGeometry = true;\n    this.type = \"LineSegmentsGeometry\";\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);\n    this.setAttribute(\"instanceStart\", new InterleavedBufferAttribute(instanceBuffer, 3, 0));\n    this.setAttribute(\"instanceEnd\", new InterleavedBufferAttribute(instanceBuffer, 3, 3));\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array, itemSize = 3) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1);\n    this.setAttribute(\"instanceColorStart\", new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0));\n    this.setAttribute(\"instanceColorEnd\", new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize));\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box.setFromBufferAttribute(end);\n      this.boundingBox.union(_box);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\", this);\n      }\n    }\n  }\n  toJSON() {}\n  applyMatrix(matrix) {\n    console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n}\nexport { LineSegmentsGeometry };","map":{"version":3,"names":["InstancedBufferGeometry","Float32BufferAttribute","InstancedInterleavedBuffer","InterleavedBufferAttribute","WireframeGeometry","Box3","Sphere","Vector3","_box","_vector","LineSegmentsGeometry","constructor","isLineSegmentsGeometry","type","positions","uvs","index","setIndex","setAttribute","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","setColors","itemSize","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","fromLineSegments","setFromBufferAttribute","union","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","console","error","toJSON","applyMatrix","warn"],"sources":["C:/Users/Marcelo/OneDrive/Documents/Desktop/e-traffic system/client/node_modules/three-stdlib/lines/LineSegmentsGeometry.js"],"sourcesContent":["import { InstancedBufferGeometry, Float32BufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute, WireframeGeometry, Box3, Sphere, Vector3 } from \"three\";\nconst _box = /* @__PURE__ */ new Box3();\nconst _vector = /* @__PURE__ */ new Vector3();\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.isLineSegmentsGeometry = true;\n    this.type = \"LineSegmentsGeometry\";\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);\n    this.setAttribute(\"instanceStart\", new InterleavedBufferAttribute(instanceBuffer, 3, 0));\n    this.setAttribute(\"instanceEnd\", new InterleavedBufferAttribute(instanceBuffer, 3, 3));\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array, itemSize = 3) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1);\n    this.setAttribute(\"instanceColorStart\", new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0));\n    this.setAttribute(\"instanceColorEnd\", new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize));\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box.setFromBufferAttribute(end);\n      this.boundingBox.union(_box);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          \"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\",\n          this\n        );\n      }\n    }\n  }\n  toJSON() {\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n}\nexport {\n  LineSegmentsGeometry\n};\n//# sourceMappingURL=LineSegmentsGeometry.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}