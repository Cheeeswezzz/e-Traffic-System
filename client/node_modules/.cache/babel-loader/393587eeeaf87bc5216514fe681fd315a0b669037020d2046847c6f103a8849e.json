{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from \"three\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\nconst LightningStrike = /* @__PURE__ */(() => {\n  const _LightningStrike = class extends BufferGeometry {\n    constructor(rayParameters = {}) {\n      super();\n      this.isLightningStrike = true;\n      this.type = \"LightningStrike\";\n      this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));\n      this.createMesh();\n    }\n    static createRandomGenerator() {\n      const numSeeds = 2053;\n      const seeds = [];\n      for (let i = 0; i < numSeeds; i++) {\n        seeds.push(Math.random());\n      }\n      const generator = {\n        currentSeed: 0,\n        random: function () {\n          const value = seeds[generator.currentSeed];\n          generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n          return value;\n        },\n        getSeed: function () {\n          return generator.currentSeed / numSeeds;\n        },\n        setSeed: function (seed) {\n          generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n        }\n      };\n      return generator;\n    }\n    static copyParameters(dest = {}, source = {}) {\n      const vecCopy = function (v) {\n        if (source === dest) {\n          return v;\n        } else {\n          return v.clone();\n        }\n      };\n      dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n      dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2,\n      // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n      dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;\n      dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;\n      dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;\n      dest.ramification = source.ramification !== void 0 ? source.ramification : 5;\n      dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;\n      dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;\n      dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;\n      dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n      return dest;\n    }\n    update(time) {\n      if (this.isStatic) return;\n      if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n        this.updateMesh(time);\n        if (time < this.subrays[0].endPropagationTime) {\n          this.state = _LightningStrike.RAY_PROPAGATING;\n        } else if (time > this.subrays[0].beginVanishingTime) {\n          this.state = _LightningStrike.RAY_VANISHING;\n        } else {\n          this.state = _LightningStrike.RAY_STEADY;\n        }\n        this.visible = true;\n      } else {\n        this.visible = false;\n        if (time < this.rayParameters.birthTime) {\n          this.state = _LightningStrike.RAY_UNBORN;\n        } else {\n          this.state = _LightningStrike.RAY_EXTINGUISHED;\n        }\n      }\n    }\n    init(rayParameters) {\n      this.rayParameters = rayParameters;\n      this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;\n      rayParameters.maxIterations = this.maxIterations;\n      this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;\n      rayParameters.isStatic = this.isStatic;\n      this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;\n      rayParameters.ramification = this.ramification;\n      this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n      rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n      this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;\n      rayParameters.recursionProbability = this.recursionProbability;\n      this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;\n      rayParameters.generateUVs = this.generateUVs;\n      if (rayParameters.randomGenerator !== void 0) {\n        this.randomGenerator = rayParameters.randomGenerator;\n        this.seedGenerator = rayParameters.randomGenerator;\n        if (rayParameters.noiseSeed !== void 0) {\n          this.seedGenerator.setSeed(rayParameters.noiseSeed);\n        }\n      } else {\n        this.randomGenerator = _LightningStrike.createRandomGenerator();\n        this.seedGenerator = Math;\n      }\n      if (rayParameters.onDecideSubrayCreation !== void 0) {\n        this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n      } else {\n        this.createDefaultSubrayCreationCallbacks();\n        if (rayParameters.onSubrayCreation !== void 0) {\n          this.onSubrayCreation = rayParameters.onSubrayCreation;\n        }\n      }\n      this.state = _LightningStrike.RAY_INITIALIZED;\n      this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n      rayParameters.maxSubrays = this.maxSubrays;\n      this.maxRaySegments = 2 * (1 << this.maxIterations);\n      this.subrays = [];\n      for (let i = 0; i < this.maxSubrays; i++) {\n        this.subrays.push(this.createSubray());\n      }\n      this.raySegments = [];\n      for (let i = 0; i < this.maxRaySegments; i++) {\n        this.raySegments.push(this.createSegment());\n      }\n      this.time = 0;\n      this.timeFraction = 0;\n      this.currentSegmentCallback = null;\n      this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n      this.numSubrays = 0;\n      this.currentSubray = null;\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = false;\n      this.subrayProbability = 0;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.vertices = null;\n      this.uvs = null;\n      this.indices = null;\n      this.positionAttribute = null;\n      this.uvsAttribute = null;\n      this.simplexX = new SimplexNoise(this.seedGenerator);\n      this.simplexY = new SimplexNoise(this.seedGenerator);\n      this.simplexZ = new SimplexNoise(this.seedGenerator);\n      this.forwards = new Vector3();\n      this.forwardsFill = new Vector3();\n      this.side = new Vector3();\n      this.down = new Vector3();\n      this.middlePos = new Vector3();\n      this.middleLinPos = new Vector3();\n      this.newPos = new Vector3();\n      this.vPos = new Vector3();\n      this.cross1 = new Vector3();\n    }\n    createMesh() {\n      const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n      const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n      const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n      this.vertices = new Float32Array(maxVerts * 3);\n      this.indices = new Uint32Array(maxIndices);\n      if (this.generateUVs) {\n        this.uvs = new Float32Array(maxVerts * 2);\n      }\n      this.fillMesh(0);\n      this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n      this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n      this.setAttribute(\"position\", this.positionAttribute);\n      if (this.generateUVs) {\n        this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n        this.setAttribute(\"uv\", this.uvsAttribute);\n      }\n      if (!this.isStatic) {\n        this.index.usage = DynamicDrawUsage;\n        this.positionAttribute.usage = DynamicDrawUsage;\n        if (this.generateUVs) {\n          this.uvsAttribute.usage = DynamicDrawUsage;\n        }\n      }\n      this.vertices = this.positionAttribute.array;\n      this.indices = this.index.array;\n      if (this.generateUVs) {\n        this.uvs = this.uvsAttribute.array;\n      }\n    }\n    updateMesh(time) {\n      this.fillMesh(time);\n      this.drawRange.count = this.currentIndex;\n      this.index.needsUpdate = true;\n      this.positionAttribute.needsUpdate = true;\n      if (this.generateUVs) {\n        this.uvsAttribute.needsUpdate = true;\n      }\n    }\n    fillMesh(time) {\n      const scope = this;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.fractalRay(time, function fillVertices(segment) {\n        const subray = scope.currentSubray;\n        if (time < subray.birthTime) {\n          return;\n        } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else if (time < subray.endPropagationTime) {\n          if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n            scope.createPrism(segment);\n            scope.onDecideSubrayCreation(segment, scope);\n          }\n        } else if (time < subray.beginVanishingTime) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else {\n          if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n            scope.createPrism(segment);\n          }\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      });\n    }\n    addNewSubray() {\n      return this.subrays[this.numSubrays++];\n    }\n    initSubray(subray, rayParameters) {\n      subray.pos0.copy(rayParameters.sourceOffset);\n      subray.pos1.copy(rayParameters.destOffset);\n      subray.up0.copy(rayParameters.up0);\n      subray.up1.copy(rayParameters.up1);\n      subray.radius0 = rayParameters.radius0;\n      subray.radius1 = rayParameters.radius1;\n      subray.birthTime = rayParameters.birthTime;\n      subray.deathTime = rayParameters.deathTime;\n      subray.timeScale = rayParameters.timeScale;\n      subray.roughness = rayParameters.roughness;\n      subray.straightness = rayParameters.straightness;\n      subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n      subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n      subray.maxIterations = this.maxIterations;\n      subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;\n      subray.recursion = 0;\n    }\n    fractalRay(time, segmentCallback) {\n      this.time = time;\n      this.currentSegmentCallback = segmentCallback;\n      this.numSubrays = 0;\n      this.initSubray(this.addNewSubray(), this.rayParameters);\n      for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n        const subray = this.subrays[subrayIndex];\n        this.currentSubray = subray;\n        this.randomGenerator.setSeed(subray.seed);\n        subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n        subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n        const random1 = this.randomGenerator.random;\n        subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n        this.currentSegmentIndex = 0;\n        this.isInitialSegment = true;\n        const segment = this.getNewSegment();\n        segment.iteration = 0;\n        segment.pos0.copy(subray.pos0);\n        segment.pos1.copy(subray.pos1);\n        segment.linPos0.copy(subray.linPos0);\n        segment.linPos1.copy(subray.linPos1);\n        segment.up0.copy(subray.up0);\n        segment.up1.copy(subray.up1);\n        segment.radius0 = subray.radius0;\n        segment.radius1 = subray.radius1;\n        segment.fraction0 = 0;\n        segment.fraction1 = 1;\n        segment.positionVariationFactor = 1 - subray.straightness;\n        this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n        this.fractalRayRecursive(segment);\n      }\n      this.currentSegmentCallback = null;\n      this.currentSubray = null;\n    }\n    fractalRayRecursive(segment) {\n      if (segment.iteration >= this.currentSubray.maxIterations) {\n        this.currentSegmentCallback(segment);\n        return;\n      }\n      this.forwards.subVectors(segment.pos1, segment.pos0);\n      let lForwards = this.forwards.length();\n      if (lForwards < 1e-6) {\n        this.forwards.set(0, 0, 0.01);\n        lForwards = this.forwards.length();\n      }\n      const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n      const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n      const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n      this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n      this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n      const p = this.middleLinPos;\n      this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n      this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n      this.newPos.add(this.middlePos);\n      const newSegment1 = this.getNewSegment();\n      newSegment1.pos0.copy(segment.pos0);\n      newSegment1.pos1.copy(this.newPos);\n      newSegment1.linPos0.copy(segment.linPos0);\n      newSegment1.linPos1.copy(this.middleLinPos);\n      newSegment1.up0.copy(segment.up0);\n      newSegment1.up1.copy(segment.up1);\n      newSegment1.radius0 = segment.radius0;\n      newSegment1.radius1 = middleRadius;\n      newSegment1.fraction0 = segment.fraction0;\n      newSegment1.fraction1 = middleFraction;\n      newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment1.iteration = segment.iteration + 1;\n      const newSegment2 = this.getNewSegment();\n      newSegment2.pos0.copy(this.newPos);\n      newSegment2.pos1.copy(segment.pos1);\n      newSegment2.linPos0.copy(this.middleLinPos);\n      newSegment2.linPos1.copy(segment.linPos1);\n      this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n      newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n      newSegment2.up1.copy(segment.up1);\n      newSegment2.radius0 = middleRadius;\n      newSegment2.radius1 = segment.radius1;\n      newSegment2.fraction0 = middleFraction;\n      newSegment2.fraction1 = segment.fraction1;\n      newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment2.iteration = segment.iteration + 1;\n      this.fractalRayRecursive(newSegment1);\n      this.fractalRayRecursive(newSegment2);\n    }\n    createPrism(segment) {\n      this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n      if (this.isInitialSegment) {\n        this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n        this.isInitialSegment = false;\n      }\n      this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n      this.createPrismFaces();\n    }\n    createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n      const p = this.vPos;\n      const v = this.vertices;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      this.currentVertex += 3;\n    }\n    createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n      const p = this.vPos;\n      const v = this.vertices;\n      const uv = this.uvs;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0.5;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 1;\n      this.currentVertex += 3;\n    }\n    createPrismFaces(vertex) {\n      const indices = this.indices;\n      vertex = this.currentVertex - 6;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 5;\n    }\n    createDefaultSubrayCreationCallbacks() {\n      const random1 = this.randomGenerator.random;\n      this.onDecideSubrayCreation = function (segment, lightningStrike) {\n        const subray = lightningStrike.currentSubray;\n        const period = lightningStrike.rayParameters.subrayPeriod;\n        const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n        const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n        const phase = lightningStrike.time - phase0;\n        const currentCycle = Math.floor(phase / period);\n        const childSubraySeed = random1() * (currentCycle + 1);\n        const isActive = phase % period <= dutyCycle * period;\n        let probability = 0;\n        if (isActive) {\n          probability = lightningStrike.subrayProbability;\n        }\n        if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n          const childSubray = lightningStrike.addNewSubray();\n          const parentSeed = lightningStrike.randomGenerator.getSeed();\n          childSubray.seed = childSubraySeed;\n          lightningStrike.randomGenerator.setSeed(childSubraySeed);\n          childSubray.recursion = subray.recursion + 1;\n          childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n          childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n          childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n          childSubray.up0.copy(subray.up0);\n          childSubray.up1.copy(subray.up1);\n          childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n          childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n          childSubray.birthTime = phase0 + currentCycle * period;\n          childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n          if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n            childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n            childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n          }\n          childSubray.timeScale = subray.timeScale * 2;\n          childSubray.roughness = subray.roughness;\n          childSubray.straightness = subray.straightness;\n          childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n          childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n          lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n          lightningStrike.randomGenerator.setSeed(parentSeed);\n        }\n      };\n      const vec1Pos = new Vector3();\n      const vec2Forward = new Vector3();\n      const vec3Side = new Vector3();\n      const vec4Up = new Vector3();\n      this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n        lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n      };\n      this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n        const length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        const angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n      this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n        const length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        const angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n    }\n    createSubray() {\n      return {\n        seed: 0,\n        maxIterations: 0,\n        recursion: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        birthTime: 0,\n        deathTime: 0,\n        timeScale: 0,\n        roughness: 0,\n        straightness: 0,\n        propagationTimeFactor: 0,\n        vanishingTimeFactor: 0,\n        endPropagationTime: 0,\n        beginVanishingTime: 0\n      };\n    }\n    createSegment() {\n      return {\n        iteration: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        fraction0: 0,\n        fraction1: 0,\n        positionVariationFactor: 0\n      };\n    }\n    getNewSegment() {\n      return this.raySegments[this.currentSegmentIndex++];\n    }\n    copy(source) {\n      super.copy(source);\n      this.init(_LightningStrike.copyParameters({}, source.rayParameters));\n      return this;\n    }\n    clone() {\n      return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));\n    }\n  };\n  let LightningStrike2 = _LightningStrike;\n  // Ray states\n  __publicField(LightningStrike2, \"RAY_INITIALIZED\", 0);\n  __publicField(LightningStrike2, \"RAY_UNBORN\", 1);\n  __publicField(LightningStrike2, \"RAY_PROPAGATING\", 2);\n  __publicField(LightningStrike2, \"RAY_STEADY\", 3);\n  __publicField(LightningStrike2, \"RAY_VANISHING\", 4);\n  __publicField(LightningStrike2, \"RAY_EXTINGUISHED\", 5);\n  __publicField(LightningStrike2, \"COS30DEG\", Math.cos(30 * Math.PI / 180));\n  __publicField(LightningStrike2, \"SIN30DEG\", Math.sin(30 * Math.PI / 180));\n  return LightningStrike2;\n})();\nexport { LightningStrike };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","BufferGeometry","Vector3","Uint32BufferAttribute","Float32BufferAttribute","DynamicDrawUsage","MathUtils","SimplexNoise","LightningStrike","_LightningStrike","constructor","rayParameters","isLightningStrike","type","init","copyParameters","createMesh","createRandomGenerator","numSeeds","seeds","i","push","Math","random","generator","currentSeed","getSeed","setSeed","seed","floor","dest","source","vecCopy","v","clone","sourceOffset","destOffset","timeScale","roughness","straightness","up0","up1","radius0","radius1","radius0Factor","radius1Factor","minRadius","isEternal","birthTime","deathTime","propagationTimeFactor","vanishingTimeFactor","subrayPeriod","subrayDutyCycle","maxIterations","isStatic","ramification","maxSubrayRecursion","recursionProbability","generateUVs","randomGenerator","noiseSeed","onDecideSubrayCreation","onSubrayCreation","update","time","updateMesh","subrays","endPropagationTime","state","RAY_PROPAGATING","beginVanishingTime","RAY_VANISHING","RAY_STEADY","visible","RAY_UNBORN","RAY_EXTINGUISHED","seedGenerator","createDefaultSubrayCreationCallbacks","RAY_INITIALIZED","maxSubrays","ceil","pow","max","maxRaySegments","createSubray","raySegments","createSegment","timeFraction","currentSegmentCallback","currentCreateTriangleVertices","createTriangleVerticesWithUVs","createTriangleVerticesWithoutUVs","numSubrays","currentSubray","currentSegmentIndex","isInitialSegment","subrayProbability","currentVertex","currentIndex","currentCoordinate","currentUVCoordinate","vertices","uvs","indices","positionAttribute","uvsAttribute","simplexX","simplexY","simplexZ","forwards","forwardsFill","side","down","middlePos","middleLinPos","newPos","vPos","cross1","maxDrawableSegmentsPerSubRay","maxVerts","maxIndices","Float32Array","Uint32Array","fillMesh","setIndex","setAttribute","index","usage","array","drawRange","count","needsUpdate","scope","fractalRay","fillVertices","segment","subray","recursion","createPrism","fraction0","fraction1","addNewSubray","initSubray","pos0","copy","pos1","segmentCallback","subrayIndex","lerp","random1","linPos0","set","multiplyScalar","linPos1","getNewSegment","iteration","positionVariationFactor","fractalRayRecursive","subVectors","lForwards","length","middleRadius","middleFraction","timeDimension","lerpVectors","p","noise4d","x","y","z","add","newSegment1","newSegment2","crossVectors","normalize","createPrismFaces","pos","up","radius","COS30DEG","SIN30DEG","sub","u","uv","vertex","lightningStrike","period","dutyCycle","phase0","phase","currentCycle","childSubraySeed","isActive","probability","childSubray","parentSeed","min","vec1Pos","vec2Forward","vec3Side","vec4Up","parentSubray","subrayCylinderPosition","subrayConePosition","heightFactor","sideWidthFactor","minSideWidthFactor","angle","PI","cos","sin","LightningStrike2"],"sources":["C:/Users/Marcelo/OneDrive/Documents/Desktop/e-traffic system/client/node_modules/three-stdlib/geometries/LightningStrike.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from \"three\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\nconst LightningStrike = /* @__PURE__ */ (() => {\n  const _LightningStrike = class extends BufferGeometry {\n    constructor(rayParameters = {}) {\n      super();\n      this.isLightningStrike = true;\n      this.type = \"LightningStrike\";\n      this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));\n      this.createMesh();\n    }\n    static createRandomGenerator() {\n      const numSeeds = 2053;\n      const seeds = [];\n      for (let i = 0; i < numSeeds; i++) {\n        seeds.push(Math.random());\n      }\n      const generator = {\n        currentSeed: 0,\n        random: function() {\n          const value = seeds[generator.currentSeed];\n          generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n          return value;\n        },\n        getSeed: function() {\n          return generator.currentSeed / numSeeds;\n        },\n        setSeed: function(seed) {\n          generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n        }\n      };\n      return generator;\n    }\n    static copyParameters(dest = {}, source = {}) {\n      const vecCopy = function(v) {\n        if (source === dest) {\n          return v;\n        } else {\n          return v.clone();\n        }\n      };\n      dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n      dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n      dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;\n      dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;\n      dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;\n      dest.ramification = source.ramification !== void 0 ? source.ramification : 5;\n      dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;\n      dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;\n      dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;\n      dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n      return dest;\n    }\n    update(time) {\n      if (this.isStatic)\n        return;\n      if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n        this.updateMesh(time);\n        if (time < this.subrays[0].endPropagationTime) {\n          this.state = _LightningStrike.RAY_PROPAGATING;\n        } else if (time > this.subrays[0].beginVanishingTime) {\n          this.state = _LightningStrike.RAY_VANISHING;\n        } else {\n          this.state = _LightningStrike.RAY_STEADY;\n        }\n        this.visible = true;\n      } else {\n        this.visible = false;\n        if (time < this.rayParameters.birthTime) {\n          this.state = _LightningStrike.RAY_UNBORN;\n        } else {\n          this.state = _LightningStrike.RAY_EXTINGUISHED;\n        }\n      }\n    }\n    init(rayParameters) {\n      this.rayParameters = rayParameters;\n      this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;\n      rayParameters.maxIterations = this.maxIterations;\n      this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;\n      rayParameters.isStatic = this.isStatic;\n      this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;\n      rayParameters.ramification = this.ramification;\n      this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n      rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n      this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;\n      rayParameters.recursionProbability = this.recursionProbability;\n      this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;\n      rayParameters.generateUVs = this.generateUVs;\n      if (rayParameters.randomGenerator !== void 0) {\n        this.randomGenerator = rayParameters.randomGenerator;\n        this.seedGenerator = rayParameters.randomGenerator;\n        if (rayParameters.noiseSeed !== void 0) {\n          this.seedGenerator.setSeed(rayParameters.noiseSeed);\n        }\n      } else {\n        this.randomGenerator = _LightningStrike.createRandomGenerator();\n        this.seedGenerator = Math;\n      }\n      if (rayParameters.onDecideSubrayCreation !== void 0) {\n        this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n      } else {\n        this.createDefaultSubrayCreationCallbacks();\n        if (rayParameters.onSubrayCreation !== void 0) {\n          this.onSubrayCreation = rayParameters.onSubrayCreation;\n        }\n      }\n      this.state = _LightningStrike.RAY_INITIALIZED;\n      this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n      rayParameters.maxSubrays = this.maxSubrays;\n      this.maxRaySegments = 2 * (1 << this.maxIterations);\n      this.subrays = [];\n      for (let i = 0; i < this.maxSubrays; i++) {\n        this.subrays.push(this.createSubray());\n      }\n      this.raySegments = [];\n      for (let i = 0; i < this.maxRaySegments; i++) {\n        this.raySegments.push(this.createSegment());\n      }\n      this.time = 0;\n      this.timeFraction = 0;\n      this.currentSegmentCallback = null;\n      this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n      this.numSubrays = 0;\n      this.currentSubray = null;\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = false;\n      this.subrayProbability = 0;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.vertices = null;\n      this.uvs = null;\n      this.indices = null;\n      this.positionAttribute = null;\n      this.uvsAttribute = null;\n      this.simplexX = new SimplexNoise(this.seedGenerator);\n      this.simplexY = new SimplexNoise(this.seedGenerator);\n      this.simplexZ = new SimplexNoise(this.seedGenerator);\n      this.forwards = new Vector3();\n      this.forwardsFill = new Vector3();\n      this.side = new Vector3();\n      this.down = new Vector3();\n      this.middlePos = new Vector3();\n      this.middleLinPos = new Vector3();\n      this.newPos = new Vector3();\n      this.vPos = new Vector3();\n      this.cross1 = new Vector3();\n    }\n    createMesh() {\n      const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n      const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n      const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n      this.vertices = new Float32Array(maxVerts * 3);\n      this.indices = new Uint32Array(maxIndices);\n      if (this.generateUVs) {\n        this.uvs = new Float32Array(maxVerts * 2);\n      }\n      this.fillMesh(0);\n      this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n      this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n      this.setAttribute(\"position\", this.positionAttribute);\n      if (this.generateUVs) {\n        this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n        this.setAttribute(\"uv\", this.uvsAttribute);\n      }\n      if (!this.isStatic) {\n        this.index.usage = DynamicDrawUsage;\n        this.positionAttribute.usage = DynamicDrawUsage;\n        if (this.generateUVs) {\n          this.uvsAttribute.usage = DynamicDrawUsage;\n        }\n      }\n      this.vertices = this.positionAttribute.array;\n      this.indices = this.index.array;\n      if (this.generateUVs) {\n        this.uvs = this.uvsAttribute.array;\n      }\n    }\n    updateMesh(time) {\n      this.fillMesh(time);\n      this.drawRange.count = this.currentIndex;\n      this.index.needsUpdate = true;\n      this.positionAttribute.needsUpdate = true;\n      if (this.generateUVs) {\n        this.uvsAttribute.needsUpdate = true;\n      }\n    }\n    fillMesh(time) {\n      const scope = this;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.fractalRay(time, function fillVertices(segment) {\n        const subray = scope.currentSubray;\n        if (time < subray.birthTime) {\n          return;\n        } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else if (time < subray.endPropagationTime) {\n          if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n            scope.createPrism(segment);\n            scope.onDecideSubrayCreation(segment, scope);\n          }\n        } else if (time < subray.beginVanishingTime) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else {\n          if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n            scope.createPrism(segment);\n          }\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      });\n    }\n    addNewSubray() {\n      return this.subrays[this.numSubrays++];\n    }\n    initSubray(subray, rayParameters) {\n      subray.pos0.copy(rayParameters.sourceOffset);\n      subray.pos1.copy(rayParameters.destOffset);\n      subray.up0.copy(rayParameters.up0);\n      subray.up1.copy(rayParameters.up1);\n      subray.radius0 = rayParameters.radius0;\n      subray.radius1 = rayParameters.radius1;\n      subray.birthTime = rayParameters.birthTime;\n      subray.deathTime = rayParameters.deathTime;\n      subray.timeScale = rayParameters.timeScale;\n      subray.roughness = rayParameters.roughness;\n      subray.straightness = rayParameters.straightness;\n      subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n      subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n      subray.maxIterations = this.maxIterations;\n      subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;\n      subray.recursion = 0;\n    }\n    fractalRay(time, segmentCallback) {\n      this.time = time;\n      this.currentSegmentCallback = segmentCallback;\n      this.numSubrays = 0;\n      this.initSubray(this.addNewSubray(), this.rayParameters);\n      for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n        const subray = this.subrays[subrayIndex];\n        this.currentSubray = subray;\n        this.randomGenerator.setSeed(subray.seed);\n        subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n        subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n        const random1 = this.randomGenerator.random;\n        subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n        this.currentSegmentIndex = 0;\n        this.isInitialSegment = true;\n        const segment = this.getNewSegment();\n        segment.iteration = 0;\n        segment.pos0.copy(subray.pos0);\n        segment.pos1.copy(subray.pos1);\n        segment.linPos0.copy(subray.linPos0);\n        segment.linPos1.copy(subray.linPos1);\n        segment.up0.copy(subray.up0);\n        segment.up1.copy(subray.up1);\n        segment.radius0 = subray.radius0;\n        segment.radius1 = subray.radius1;\n        segment.fraction0 = 0;\n        segment.fraction1 = 1;\n        segment.positionVariationFactor = 1 - subray.straightness;\n        this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n        this.fractalRayRecursive(segment);\n      }\n      this.currentSegmentCallback = null;\n      this.currentSubray = null;\n    }\n    fractalRayRecursive(segment) {\n      if (segment.iteration >= this.currentSubray.maxIterations) {\n        this.currentSegmentCallback(segment);\n        return;\n      }\n      this.forwards.subVectors(segment.pos1, segment.pos0);\n      let lForwards = this.forwards.length();\n      if (lForwards < 1e-6) {\n        this.forwards.set(0, 0, 0.01);\n        lForwards = this.forwards.length();\n      }\n      const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n      const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n      const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n      this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n      this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n      const p = this.middleLinPos;\n      this.newPos.set(\n        this.simplexX.noise4d(p.x, p.y, p.z, timeDimension),\n        this.simplexY.noise4d(p.x, p.y, p.z, timeDimension),\n        this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension)\n      );\n      this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n      this.newPos.add(this.middlePos);\n      const newSegment1 = this.getNewSegment();\n      newSegment1.pos0.copy(segment.pos0);\n      newSegment1.pos1.copy(this.newPos);\n      newSegment1.linPos0.copy(segment.linPos0);\n      newSegment1.linPos1.copy(this.middleLinPos);\n      newSegment1.up0.copy(segment.up0);\n      newSegment1.up1.copy(segment.up1);\n      newSegment1.radius0 = segment.radius0;\n      newSegment1.radius1 = middleRadius;\n      newSegment1.fraction0 = segment.fraction0;\n      newSegment1.fraction1 = middleFraction;\n      newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment1.iteration = segment.iteration + 1;\n      const newSegment2 = this.getNewSegment();\n      newSegment2.pos0.copy(this.newPos);\n      newSegment2.pos1.copy(segment.pos1);\n      newSegment2.linPos0.copy(this.middleLinPos);\n      newSegment2.linPos1.copy(segment.linPos1);\n      this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n      newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n      newSegment2.up1.copy(segment.up1);\n      newSegment2.radius0 = middleRadius;\n      newSegment2.radius1 = segment.radius1;\n      newSegment2.fraction0 = middleFraction;\n      newSegment2.fraction1 = segment.fraction1;\n      newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment2.iteration = segment.iteration + 1;\n      this.fractalRayRecursive(newSegment1);\n      this.fractalRayRecursive(newSegment2);\n    }\n    createPrism(segment) {\n      this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n      if (this.isInitialSegment) {\n        this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n        this.isInitialSegment = false;\n      }\n      this.currentCreateTriangleVertices(\n        segment.pos1,\n        segment.up0,\n        this.forwardsFill,\n        segment.radius1,\n        segment.fraction1\n      );\n      this.createPrismFaces();\n    }\n    createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n      const p = this.vPos;\n      const v = this.vertices;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      this.currentVertex += 3;\n    }\n    createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n      const p = this.vPos;\n      const v = this.vertices;\n      const uv = this.uvs;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0.5;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 1;\n      this.currentVertex += 3;\n    }\n    createPrismFaces(vertex) {\n      const indices = this.indices;\n      vertex = this.currentVertex - 6;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 5;\n    }\n    createDefaultSubrayCreationCallbacks() {\n      const random1 = this.randomGenerator.random;\n      this.onDecideSubrayCreation = function(segment, lightningStrike) {\n        const subray = lightningStrike.currentSubray;\n        const period = lightningStrike.rayParameters.subrayPeriod;\n        const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n        const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n        const phase = lightningStrike.time - phase0;\n        const currentCycle = Math.floor(phase / period);\n        const childSubraySeed = random1() * (currentCycle + 1);\n        const isActive = phase % period <= dutyCycle * period;\n        let probability = 0;\n        if (isActive) {\n          probability = lightningStrike.subrayProbability;\n        }\n        if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n          const childSubray = lightningStrike.addNewSubray();\n          const parentSeed = lightningStrike.randomGenerator.getSeed();\n          childSubray.seed = childSubraySeed;\n          lightningStrike.randomGenerator.setSeed(childSubraySeed);\n          childSubray.recursion = subray.recursion + 1;\n          childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n          childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n          childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n          childSubray.up0.copy(subray.up0);\n          childSubray.up1.copy(subray.up1);\n          childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n          childSubray.radius1 = Math.min(\n            lightningStrike.rayParameters.minRadius,\n            segment.radius1 * lightningStrike.rayParameters.radius1Factor\n          );\n          childSubray.birthTime = phase0 + currentCycle * period;\n          childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n          if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n            childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n            childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n          }\n          childSubray.timeScale = subray.timeScale * 2;\n          childSubray.roughness = subray.roughness;\n          childSubray.straightness = subray.straightness;\n          childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n          childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n          lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n          lightningStrike.randomGenerator.setSeed(parentSeed);\n        }\n      };\n      const vec1Pos = new Vector3();\n      const vec2Forward = new Vector3();\n      const vec3Side = new Vector3();\n      const vec4Up = new Vector3();\n      this.onSubrayCreation = function(segment, parentSubray, childSubray, lightningStrike) {\n        lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n      };\n      this.subrayConePosition = function(segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n        const length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        const angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n      this.subrayCylinderPosition = function(segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n        const length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        const angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n    }\n    createSubray() {\n      return {\n        seed: 0,\n        maxIterations: 0,\n        recursion: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        birthTime: 0,\n        deathTime: 0,\n        timeScale: 0,\n        roughness: 0,\n        straightness: 0,\n        propagationTimeFactor: 0,\n        vanishingTimeFactor: 0,\n        endPropagationTime: 0,\n        beginVanishingTime: 0\n      };\n    }\n    createSegment() {\n      return {\n        iteration: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        fraction0: 0,\n        fraction1: 0,\n        positionVariationFactor: 0\n      };\n    }\n    getNewSegment() {\n      return this.raySegments[this.currentSegmentIndex++];\n    }\n    copy(source) {\n      super.copy(source);\n      this.init(_LightningStrike.copyParameters({}, source.rayParameters));\n      return this;\n    }\n    clone() {\n      return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));\n    }\n  };\n  let LightningStrike2 = _LightningStrike;\n  // Ray states\n  __publicField(LightningStrike2, \"RAY_INITIALIZED\", 0);\n  __publicField(LightningStrike2, \"RAY_UNBORN\", 1);\n  __publicField(LightningStrike2, \"RAY_PROPAGATING\", 2);\n  __publicField(LightningStrike2, \"RAY_STEADY\", 3);\n  __publicField(LightningStrike2, \"RAY_VANISHING\", 4);\n  __publicField(LightningStrike2, \"RAY_EXTINGUISHED\", 5);\n  __publicField(LightningStrike2, \"COS30DEG\", Math.cos(30 * Math.PI / 180));\n  __publicField(LightningStrike2, \"SIN30DEG\", Math.sin(30 * Math.PI / 180));\n  return LightningStrike2;\n})();\nexport {\n  LightningStrike\n};\n//# sourceMappingURL=LightningStrike.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}