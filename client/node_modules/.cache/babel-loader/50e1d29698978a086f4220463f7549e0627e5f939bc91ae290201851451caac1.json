{"ast":null,"code":"import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: /* @__PURE__ */new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [/* @__PURE__ */new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1e3\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    #include <common>\n\n    uniform vec2 size;\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    void main() {\n    \tvUv = uv;\n    \tvInvSize = 1.0 / size;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    #include <common>\n    #include <packing>\n\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform float depthCutoff;\n\n    uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n    uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#endif\n    }\n\n    void main() {\n    \tfloat depth = getDepth( vUv );\n    \tif( depth >= ( 1.0 - EPSILON ) ) {\n    \t\tdiscard;\n    \t}\n\n    \tfloat centerViewZ = -getViewZ( depth );\n    \tbool rBreak = false, lBreak = false;\n\n    \tfloat weightSum = sampleWeights[0];\n    \tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n    \tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n    \t\tfloat sampleWeight = sampleWeights[i];\n    \t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n    \t\tvec2 sampleUv = vUv + sampleUvOffset;\n    \t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n    \t\tif( ! rBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t\tsampleUv = vUv - sampleUvOffset;\n    \t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n    \t\tif( ! lBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = diffuseSum / weightSum;\n    }\n  `)\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };","map":{"version":3,"names":["Vector2","DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","stdDev2","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","shader","needsUpdate"],"sources":["C:/Users/Marcelo/OneDrive/Documents/Desktop/e-traffic system/client/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js"],"sourcesContent":["import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: { value: null },\n    size: { value: /* @__PURE__ */ new Vector2(512, 512) },\n    sampleUvOffsets: { value: [/* @__PURE__ */ new Vector2(0, 0)] },\n    sampleWeights: { value: [1] },\n    tDepth: { value: null },\n    cameraNear: { value: 10 },\n    cameraFar: { value: 1e3 },\n    depthCutoff: { value: 10 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    #include <common>\n\n    uniform vec2 size;\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    void main() {\n    \tvUv = uv;\n    \tvInvSize = 1.0 / size;\n\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    #include <common>\n    #include <packing>\n\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n    uniform float depthCutoff;\n\n    uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n    uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n    varying vec2 vUv;\n    varying vec2 vInvSize;\n\n    float getDepth( const in vec2 screenPosition ) {\n    \t#if DEPTH_PACKING == 1\n    \treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n    \t#else\n    \treturn texture2D( tDepth, screenPosition ).x;\n    \t#endif\n    }\n\n    float getViewZ( const in float depth ) {\n    \t#if PERSPECTIVE_CAMERA == 1\n    \treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#else\n    \treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n    \t#endif\n    }\n\n    void main() {\n    \tfloat depth = getDepth( vUv );\n    \tif( depth >= ( 1.0 - EPSILON ) ) {\n    \t\tdiscard;\n    \t}\n\n    \tfloat centerViewZ = -getViewZ( depth );\n    \tbool rBreak = false, lBreak = false;\n\n    \tfloat weightSum = sampleWeights[0];\n    \tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n    \tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n    \t\tfloat sampleWeight = sampleWeights[i];\n    \t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n    \t\tvec2 sampleUv = vUv + sampleUvOffset;\n    \t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n    \t\tif( ! rBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t\tsampleUv = vUv - sampleUvOffset;\n    \t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n    \t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n    \t\tif( ! lBreak ) {\n    \t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n    \t\t\tweightSum += sampleWeight;\n    \t\t}\n\n    \t}\n\n    \tgl_FragColor = diffuseSum / weightSum;\n    }\n  `\n  )\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport {\n  BlurShaderUtils,\n  DepthLimitedBlurShader\n};\n//# sourceMappingURL=DepthLimitedBlurShader.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}